// Code generated by the Encore 1.53.2 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/
import type { CookieWithOptions } from "encore.dev/api";

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = "http://localhost:4000"

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
    return `https://${name}-.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
    return Environment(`pr${pr}`)
}

const BROWSER = typeof globalThis === "object" && ("window" in globalThis);

/**
 * Client is an API client for the  Encore application.
 */
export class Client {
    public readonly admin: admin.ServiceClient
    public readonly analytics: analytics.ServiceClient
    public readonly auth: auth.ServiceClient
    public readonly availability: availability.ServiceClient
    public readonly bookings: bookings.ServiceClient
    public readonly content: content.ServiceClient
    public readonly coupons: coupons.ServiceClient
    public readonly disputes: disputes.ServiceClient
    public readonly favorites: favorites.ServiceClient
    public readonly freelancers: freelancers.ServiceClient
    public readonly health: health.ServiceClient
    public readonly loyalty: loyalty.ServiceClient
    public readonly messages: messages.ServiceClient
    public readonly notifications: notifications.ServiceClient
    public readonly packages: packages.ServiceClient
    public readonly payments: payments.ServiceClient
    public readonly payouts: payouts.ServiceClient
    public readonly policies: policies.ServiceClient
    public readonly profiles: profiles.ServiceClient
    public readonly referrals: referrals.ServiceClient
    public readonly reports: reports.ServiceClient
    public readonly reviews: reviews.ServiceClient
    public readonly safety: safety.ServiceClient
    public readonly search: search.ServiceClient
    public readonly services: services.ServiceClient
    public readonly styles: styles.ServiceClient
    public readonly verification: verification.ServiceClient
    private readonly options: ClientOptions
    private readonly target: string


    /**
     * Creates a Client for calling the public and authenticated APIs of your Encore application.
     *
     * @param target  The target which the client should be configured to use. See Local and Environment for options.
     * @param options Options for the client
     */
    constructor(target: BaseURL, options?: ClientOptions) {
        this.target = target
        this.options = options ?? {}
        const base = new BaseClient(this.target, this.options)
        this.admin = new admin.ServiceClient(base)
        this.analytics = new analytics.ServiceClient(base)
        this.auth = new auth.ServiceClient(base)
        this.availability = new availability.ServiceClient(base)
        this.bookings = new bookings.ServiceClient(base)
        this.content = new content.ServiceClient(base)
        this.coupons = new coupons.ServiceClient(base)
        this.disputes = new disputes.ServiceClient(base)
        this.favorites = new favorites.ServiceClient(base)
        this.freelancers = new freelancers.ServiceClient(base)
        this.health = new health.ServiceClient(base)
        this.loyalty = new loyalty.ServiceClient(base)
        this.messages = new messages.ServiceClient(base)
        this.notifications = new notifications.ServiceClient(base)
        this.packages = new packages.ServiceClient(base)
        this.payments = new payments.ServiceClient(base)
        this.payouts = new payouts.ServiceClient(base)
        this.policies = new policies.ServiceClient(base)
        this.profiles = new profiles.ServiceClient(base)
        this.referrals = new referrals.ServiceClient(base)
        this.reports = new reports.ServiceClient(base)
        this.reviews = new reviews.ServiceClient(base)
        this.safety = new safety.ServiceClient(base)
        this.search = new search.ServiceClient(base)
        this.services = new services.ServiceClient(base)
        this.styles = new styles.ServiceClient(base)
        this.verification = new verification.ServiceClient(base)
    }

    /**
     * Creates a new Encore client with the given client options set.
     *
     * @param options Client options to set. They are merged with existing options.
     **/
    public with(options: ClientOptions): Client {
        return new Client(this.target, {
            ...this.options,
            ...options,
        })
    }
}

/**
 * Import the auth handler to be able to derive the auth type
 */
import type { auth as auth_auth } from "~backend/auth/auth";

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
    /**
     * By default the client will use the inbuilt fetch function for making the API requests.
     * however you can override it with your own implementation here if you want to run custom
     * code on each API request made or response received.
     */
    fetcher?: Fetcher

    /** Default RequestInit to be used for the client */
    requestInit?: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }

    /**
     * Allows you to set the authentication data to be used for each
     * request either by passing in a static object or by passing in
     * a function which returns a new object for each request.
     */
    auth?: RequestType<typeof auth_auth> | AuthDataGenerator
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { listAuditLogs as api_admin_audit_logs_listAuditLogs } from "~backend/admin/audit_logs";
import { deactivateService as api_admin_deactivate_service_deactivateService } from "~backend/admin/deactivate_service";
import { getBooking as api_admin_get_booking_getBooking } from "~backend/admin/get_booking";
import { getUser as api_admin_get_user_getUser } from "~backend/admin/get_user";
import { listBookings as api_admin_list_bookings_listBookings } from "~backend/admin/list_bookings";
import { listLogs as api_admin_list_logs_listLogs } from "~backend/admin/list_logs";
import { listServices as api_admin_list_services_listServices } from "~backend/admin/list_services";
import { listUsers as api_admin_list_users_listUsers } from "~backend/admin/list_users";
import {
    getMyPermissions as api_admin_rbac_getMyPermissions,
    updateAdminRole as api_admin_rbac_updateAdminRole
} from "~backend/admin/rbac";
import { reactivateService as api_admin_reactivate_service_reactivateService } from "~backend/admin/reactivate_service";
import {
    listServicesEnhanced as api_admin_services_enhanced_listServicesEnhanced,
    updateServiceStatus as api_admin_services_enhanced_updateServiceStatus
} from "~backend/admin/services_enhanced";
import {
    getSettings as api_admin_settings_enhanced_getSettings,
    updateSettings as api_admin_settings_enhanced_updateSettings
} from "~backend/admin/settings_enhanced";
import { suspendUser as api_admin_suspend_user_suspendUser } from "~backend/admin/suspend_user";
import { unsuspendUser as api_admin_unsuspend_user_unsuspendUser } from "~backend/admin/unsuspend_user";
import {
    getUserDetail as api_admin_users_enhanced_getUserDetail,
    listUsersEnhanced as api_admin_users_enhanced_listUsersEnhanced,
    updateUserStatus as api_admin_users_enhanced_updateUserStatus
} from "~backend/admin/users_enhanced";

export namespace admin {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.deactivateService = this.deactivateService.bind(this)
            this.getBooking = this.getBooking.bind(this)
            this.getMyPermissions = this.getMyPermissions.bind(this)
            this.getSettings = this.getSettings.bind(this)
            this.getUser = this.getUser.bind(this)
            this.getUserDetail = this.getUserDetail.bind(this)
            this.listAuditLogs = this.listAuditLogs.bind(this)
            this.listBookings = this.listBookings.bind(this)
            this.listLogs = this.listLogs.bind(this)
            this.listServices = this.listServices.bind(this)
            this.listServicesEnhanced = this.listServicesEnhanced.bind(this)
            this.listUsers = this.listUsers.bind(this)
            this.listUsersEnhanced = this.listUsersEnhanced.bind(this)
            this.reactivateService = this.reactivateService.bind(this)
            this.suspendUser = this.suspendUser.bind(this)
            this.unsuspendUser = this.unsuspendUser.bind(this)
            this.updateAdminRole = this.updateAdminRole.bind(this)
            this.updateServiceStatus = this.updateServiceStatus.bind(this)
            this.updateSettings = this.updateSettings.bind(this)
            this.updateUserStatus = this.updateUserStatus.bind(this)
        }

        public async deactivateService(params: RequestType<typeof api_admin_deactivate_service_deactivateService>): Promise<void> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                reason: params.reason,
            }

            await this.baseClient.callTypedAPI(`/admin/services/${encodeURIComponent(params.serviceId)}/deactivate`, {method: "POST", body: JSON.stringify(body)})
        }

        public async getBooking(params: { bookingId: string }): Promise<ResponseType<typeof api_admin_get_booking_getBooking>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/bookings/${encodeURIComponent(params.bookingId)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_get_booking_getBooking>
        }

        /**
         * Get current admin's permissions
         */
        public async getMyPermissions(): Promise<ResponseType<typeof api_admin_rbac_getMyPermissions>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/permissions`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_rbac_getMyPermissions>
        }

        public async getSettings(): Promise<ResponseType<typeof api_admin_settings_enhanced_getSettings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/settings/platform`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_settings_enhanced_getSettings>
        }

        public async getUser(params: { userId: string }): Promise<ResponseType<typeof api_admin_get_user_getUser>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/users/${encodeURIComponent(params.userId)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_get_user_getUser>
        }

        public async getUserDetail(params: { userId: string }): Promise<ResponseType<typeof api_admin_users_enhanced_getUserDetail>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/users/${encodeURIComponent(params.userId)}/detail`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_users_enhanced_getUserDetail>
        }

        public async listAuditLogs(params: RequestType<typeof api_admin_audit_logs_listAuditLogs>): Promise<ResponseType<typeof api_admin_audit_logs_listAuditLogs>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                actorId:    params.actorId,
                endDate:    params.endDate,
                eventType:  params.eventType === undefined ? undefined : String(params.eventType),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                startDate:  params.startDate,
                targetId:   params.targetId,
                targetType: params.targetType,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/audit-logs`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_audit_logs_listAuditLogs>
        }

        public async listBookings(params: RequestType<typeof api_admin_list_bookings_listBookings>): Promise<ResponseType<typeof api_admin_list_bookings_listBookings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/bookings/list`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_list_bookings_listBookings>
        }

        public async listLogs(params: RequestType<typeof api_admin_list_logs_listLogs>): Promise<ResponseType<typeof api_admin_list_logs_listLogs>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/logs/list`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_list_logs_listLogs>
        }

        public async listServices(params: RequestType<typeof api_admin_list_services_listServices>): Promise<ResponseType<typeof api_admin_list_services_listServices>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/services/list`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_list_services_listServices>
        }

        public async listServicesEnhanced(params: RequestType<typeof api_admin_services_enhanced_listServicesEnhanced>): Promise<ResponseType<typeof api_admin_services_enhanced_listServicesEnhanced>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:  params.category,
                city:      params.city,
                limit:     params.limit === undefined ? undefined : String(params.limit),
                page:      params.page === undefined ? undefined : String(params.page),
                priceMax:  params.priceMax === undefined ? undefined : String(params.priceMax),
                priceMin:  params.priceMin === undefined ? undefined : String(params.priceMin),
                search:    params.search,
                sortBy:    params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder: params.sortOrder === undefined ? undefined : String(params.sortOrder),
                status:    params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/services/enhanced`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_services_enhanced_listServicesEnhanced>
        }

        public async listUsers(params: RequestType<typeof api_admin_list_users_listUsers>): Promise<ResponseType<typeof api_admin_list_users_listUsers>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/users/list`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_list_users_listUsers>
        }

        public async listUsersEnhanced(params: RequestType<typeof api_admin_users_enhanced_listUsersEnhanced>): Promise<ResponseType<typeof api_admin_users_enhanced_listUsersEnhanced>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                city:      params.city,
                kycStatus: params.kycStatus === undefined ? undefined : String(params.kycStatus),
                limit:     params.limit === undefined ? undefined : String(params.limit),
                page:      params.page === undefined ? undefined : String(params.page),
                role:      params.role === undefined ? undefined : String(params.role),
                search:    params.search,
                sortBy:    params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder: params.sortOrder === undefined ? undefined : String(params.sortOrder),
                status:    params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/users/enhanced`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_users_enhanced_listUsersEnhanced>
        }

        public async reactivateService(params: { serviceId: string }): Promise<void> {
            await this.baseClient.callTypedAPI(`/admin/services/${encodeURIComponent(params.serviceId)}/reactivate`, {method: "POST", body: undefined})
        }

        public async suspendUser(params: RequestType<typeof api_admin_suspend_user_suspendUser>): Promise<void> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                reason: params.reason,
            }

            await this.baseClient.callTypedAPI(`/admin/users/${encodeURIComponent(params.userId)}/suspend`, {method: "POST", body: JSON.stringify(body)})
        }

        public async unsuspendUser(params: { userId: string }): Promise<void> {
            await this.baseClient.callTypedAPI(`/admin/users/${encodeURIComponent(params.userId)}/unsuspend`, {method: "POST", body: undefined})
        }

        /**
         * Update admin role (super_admin only)
         */
        public async updateAdminRole(params: RequestType<typeof api_admin_rbac_updateAdminRole>): Promise<ResponseType<typeof api_admin_rbac_updateAdminRole>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                adminRole: params.adminRole,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/users/${encodeURIComponent(params.userId)}/role`, {method: "PUT", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_rbac_updateAdminRole>
        }

        /**
         * Activate/deactivate service
         */
        public async updateServiceStatus(params: RequestType<typeof api_admin_services_enhanced_updateServiceStatus>): Promise<ResponseType<typeof api_admin_services_enhanced_updateServiceStatus>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                isActive: params.isActive,
                reason:   params.reason,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/services/${encodeURIComponent(params.serviceId)}/status`, {method: "PUT", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_services_enhanced_updateServiceStatus>
        }

        public async updateSettings(params: RequestType<typeof api_admin_settings_enhanced_updateSettings>): Promise<ResponseType<typeof api_admin_settings_enhanced_updateSettings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/settings/platform`, {method: "PUT", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_settings_enhanced_updateSettings>
        }

        /**
         * Suspend/unsuspend user
         */
        public async updateUserStatus(params: RequestType<typeof api_admin_users_enhanced_updateUserStatus>): Promise<ResponseType<typeof api_admin_users_enhanced_updateUserStatus>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                reason: params.reason,
                status: params.status,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/users/${encodeURIComponent(params.userId)}/status`, {method: "PUT", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_users_enhanced_updateUserStatus>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import {
    getCityAnalytics as api_analytics_city_metrics_getCityAnalytics,
    getSupportedCities as api_analytics_city_metrics_getSupportedCities
} from "~backend/analytics/city_metrics";
import { getKPIs as api_analytics_get_kpis_getKPIs } from "~backend/analytics/get_kpis";
import { track as api_analytics_track_track } from "~backend/analytics/track";

export namespace analytics {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getCityAnalytics = this.getCityAnalytics.bind(this)
            this.getKPIs = this.getKPIs.bind(this)
            this.getSupportedCities = this.getSupportedCities.bind(this)
            this.track = this.track.bind(this)
        }

        public async getCityAnalytics(params: RequestType<typeof api_analytics_city_metrics_getCityAnalytics>): Promise<ResponseType<typeof api_analytics_city_metrics_getCityAnalytics>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                cities:    params.cities?.map((v) => v),
                endDate:   params.endDate,
                startDate: params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/analytics/cities`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_analytics_city_metrics_getCityAnalytics>
        }

        public async getKPIs(): Promise<ResponseType<typeof api_analytics_get_kpis_getKPIs>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/analytics/kpis`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_analytics_get_kpis_getKPIs>
        }

        /**
         * Get list of supported cities for frontend
         */
        public async getSupportedCities(): Promise<ResponseType<typeof api_analytics_city_metrics_getSupportedCities>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/cities`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_analytics_city_metrics_getSupportedCities>
        }

        public async track(params: RequestType<typeof api_analytics_track_track>): Promise<ResponseType<typeof api_analytics_track_track>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/analytics/track`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_analytics_track_track>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { adminVerifyUser as api_auth_admin_verify_user_adminVerifyUser } from "~backend/auth/admin_verify_user";
import { becomeFreelancer as api_auth_become_freelancer_becomeFreelancer } from "~backend/auth/become_freelancer";
import { forgotPassword as api_auth_forgot_password_forgotPassword } from "~backend/auth/forgot_password";
import { login as api_auth_login_login } from "~backend/auth/login";
import { logout as api_auth_logout_logout } from "~backend/auth/logout";
import { me as api_auth_me_me } from "~backend/auth/me";
import { register as api_auth_register_register } from "~backend/auth/register";
import { resendVerification as api_auth_resend_verification_resendVerification } from "~backend/auth/resend_verification";
import { resetPassword as api_auth_reset_password_resetPassword } from "~backend/auth/reset_password";
import {
    getRoles as api_auth_roles_getRoles,
    legacySwitchRole as api_auth_roles_legacySwitchRole,
    startFreelancerOnboarding as api_auth_roles_startFreelancerOnboarding
} from "~backend/auth/roles";
import { switchRole as api_auth_switch_role_switchRole } from "~backend/auth/switch_role";
import { updateProfile as api_auth_update_profile_updateProfile } from "~backend/auth/update_profile";
import { verify as api_auth_verify_verify } from "~backend/auth/verify";

export namespace auth {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.adminVerifyUser = this.adminVerifyUser.bind(this)
            this.becomeFreelancer = this.becomeFreelancer.bind(this)
            this.forgotPassword = this.forgotPassword.bind(this)
            this.getRoles = this.getRoles.bind(this)
            this.legacySwitchRole = this.legacySwitchRole.bind(this)
            this.login = this.login.bind(this)
            this.logout = this.logout.bind(this)
            this.me = this.me.bind(this)
            this.register = this.register.bind(this)
            this.resendVerification = this.resendVerification.bind(this)
            this.resetPassword = this.resetPassword.bind(this)
            this.startFreelancerOnboarding = this.startFreelancerOnboarding.bind(this)
            this.switchRole = this.switchRole.bind(this)
            this.updateProfile = this.updateProfile.bind(this)
            this.verify = this.verify.bind(this)
        }

        public async adminVerifyUser(params: RequestType<typeof api_auth_admin_verify_user_adminVerifyUser>): Promise<ResponseType<typeof api_auth_admin_verify_user_adminVerifyUser>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/admin/verify-user`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_admin_verify_user_adminVerifyUser>
        }

        public async becomeFreelancer(params: RequestType<typeof api_auth_become_freelancer_becomeFreelancer>): Promise<ResponseType<typeof api_auth_become_freelancer_becomeFreelancer>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/become-freelancer`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_become_freelancer_becomeFreelancer>
        }

        public async forgotPassword(params: RequestType<typeof api_auth_forgot_password_forgotPassword>): Promise<ResponseType<typeof api_auth_forgot_password_forgotPassword>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/forgot-password`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_forgot_password_forgotPassword>
        }

        public async getRoles(): Promise<ResponseType<typeof api_auth_roles_getRoles>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/roles`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_roles_getRoles>
        }

        /**
         * NOTE: Deprecated - use switch_role.ts instead
         * Keeping for backward compatibility
         */
        public async legacySwitchRole(params: RequestType<typeof api_auth_roles_legacySwitchRole>): Promise<ResponseType<typeof api_auth_roles_legacySwitchRole>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/legacy-switch-role`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_roles_legacySwitchRole>
        }

        public async login(params: RequestType<typeof api_auth_login_login>): Promise<ResponseType<typeof api_auth_login_login>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/login`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_login_login>
        }

        public async logout(): Promise<ResponseType<typeof api_auth_logout_logout>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/logout`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_logout_logout>
        }

        public async me(): Promise<ResponseType<typeof api_auth_me_me>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/me`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_me_me>
        }

        public async register(params: RequestType<typeof api_auth_register_register>): Promise<ResponseType<typeof api_auth_register_register>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/register`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_register_register>
        }

        public async resendVerification(params: RequestType<typeof api_auth_resend_verification_resendVerification>): Promise<ResponseType<typeof api_auth_resend_verification_resendVerification>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/resend-verification`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_resend_verification_resendVerification>
        }

        public async resetPassword(params: RequestType<typeof api_auth_reset_password_resetPassword>): Promise<ResponseType<typeof api_auth_reset_password_resetPassword>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/reset-password`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_reset_password_resetPassword>
        }

        public async startFreelancerOnboarding(params: RequestType<typeof api_auth_roles_startFreelancerOnboarding>): Promise<ResponseType<typeof api_auth_roles_startFreelancerOnboarding>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/start-freelancer-onboarding`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_roles_startFreelancerOnboarding>
        }

        public async switchRole(params: RequestType<typeof api_auth_switch_role_switchRole>): Promise<ResponseType<typeof api_auth_switch_role_switchRole>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/switch-role`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_switch_role_switchRole>
        }

        public async updateProfile(params: RequestType<typeof api_auth_update_profile_updateProfile>): Promise<ResponseType<typeof api_auth_update_profile_updateProfile>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/profile`, {method: "PUT", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_update_profile_updateProfile>
        }

        public async verify(params: RequestType<typeof api_auth_verify_verify>): Promise<ResponseType<typeof api_auth_verify_verify>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/auth/verify`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_auth_verify_verify>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { addException as api_availability_add_exception_addException } from "~backend/availability/add_exception";
import {
    blockTime as api_availability_calendar_blockTime,
    exportIcal as api_availability_calendar_exportIcal,
    getCalendar as api_availability_calendar_getCalendar,
    unblockTime as api_availability_calendar_unblockTime
} from "~backend/availability/calendar";
import { deleteException as api_availability_delete_exception_deleteException } from "~backend/availability/delete_exception";
import { getRules as api_availability_get_rules_getRules } from "~backend/availability/get_rules";
import { getSchedule as api_availability_get_schedule_getSchedule } from "~backend/availability/get_schedule";
import { getServiceSlots as api_availability_get_service_slots_getServiceSlots } from "~backend/availability/get_service_slots";
import { getSettings as api_availability_get_settings_getSettings } from "~backend/availability/get_settings";
import { listExceptions as api_availability_list_exceptions_listExceptions } from "~backend/availability/list_exceptions";
import { setRules as api_availability_set_rules_setRules } from "~backend/availability/set_rules";
import { setSettings as api_availability_set_settings_setSettings } from "~backend/availability/set_settings";

export namespace availability {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addException = this.addException.bind(this)
            this.blockTime = this.blockTime.bind(this)
            this.deleteException = this.deleteException.bind(this)
            this.exportIcal = this.exportIcal.bind(this)
            this.getCalendar = this.getCalendar.bind(this)
            this.getRules = this.getRules.bind(this)
            this.getSchedule = this.getSchedule.bind(this)
            this.getServiceSlots = this.getServiceSlots.bind(this)
            this.getSettings = this.getSettings.bind(this)
            this.listExceptions = this.listExceptions.bind(this)
            this.setRules = this.setRules.bind(this)
            this.setSettings = this.setSettings.bind(this)
            this.unblockTime = this.unblockTime.bind(this)
        }

        public async addException(params: RequestType<typeof api_availability_add_exception_addException>): Promise<ResponseType<typeof api_availability_add_exception_addException>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/exceptions`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_add_exception_addException>
        }

        public async blockTime(params: RequestType<typeof api_availability_calendar_blockTime>): Promise<ResponseType<typeof api_availability_calendar_blockTime>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/block`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_calendar_blockTime>
        }

        public async deleteException(params: { id: number }): Promise<ResponseType<typeof api_availability_delete_exception_deleteException>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/exceptions/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_delete_exception_deleteException>
        }

        /**
         * iCal export
         */
        public async exportIcal(): Promise<ResponseType<typeof api_availability_calendar_exportIcal>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/ical`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_calendar_exportIcal>
        }

        public async getCalendar(params: RequestType<typeof api_availability_calendar_getCalendar>): Promise<ResponseType<typeof api_availability_calendar_getCalendar>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:   params.endDate,
                startDate: params.startDate,
                view:      params.view === undefined ? undefined : String(params.view),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/calendar`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_calendar_getCalendar>
        }

        public async getRules(): Promise<ResponseType<typeof api_availability_get_rules_getRules>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/rules`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_get_rules_getRules>
        }

        public async getSchedule(params: RequestType<typeof api_availability_get_schedule_getSchedule>): Promise<ResponseType<typeof api_availability_get_schedule_getSchedule>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date: params.date,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/schedule`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_get_schedule_getSchedule>
        }

        public async getServiceSlots(params: RequestType<typeof api_availability_get_service_slots_getServiceSlots>): Promise<ResponseType<typeof api_availability_get_service_slots_getServiceSlots>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date: params.date,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/availability`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_get_service_slots_getServiceSlots>
        }

        public async getSettings(): Promise<ResponseType<typeof api_availability_get_settings_getSettings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/settings`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_get_settings_getSettings>
        }

        public async listExceptions(params: RequestType<typeof api_availability_list_exceptions_listExceptions>): Promise<ResponseType<typeof api_availability_list_exceptions_listExceptions>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:   params.endDate,
                startDate: params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/exceptions`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_list_exceptions_listExceptions>
        }

        public async setRules(params: RequestType<typeof api_availability_set_rules_setRules>): Promise<ResponseType<typeof api_availability_set_rules_setRules>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/rules`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_set_rules_setRules>
        }

        public async setSettings(params: RequestType<typeof api_availability_set_settings_setSettings>): Promise<ResponseType<typeof api_availability_set_settings_setSettings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/settings`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_set_settings_setSettings>
        }

        public async unblockTime(params: { id: number }): Promise<ResponseType<typeof api_availability_calendar_unblockTime>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/availability/block/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_availability_calendar_unblockTime>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { accept as api_bookings_accept_accept } from "~backend/bookings/accept";
import { cancel as api_bookings_cancel_cancel } from "~backend/bookings/cancel";
import { create as api_bookings_create_create } from "~backend/bookings/create";
import { decline as api_bookings_decline_decline } from "~backend/bookings/decline";
import { get as api_bookings_get_get } from "~backend/bookings/get";
import { getDashboardStats as api_bookings_get_dashboard_stats_getDashboardStats } from "~backend/bookings/get_dashboard_stats";
import { getSlots as api_bookings_get_slots_getSlots } from "~backend/bookings/get_slots";
import { list as api_bookings_list_list } from "~backend/bookings/list";
import { listRescheduleRequests as api_bookings_list_reschedule_requests_listRescheduleRequests } from "~backend/bookings/list_reschedule_requests";
import {
    createMultiServiceBooking as api_bookings_multi_service_createMultiServiceBooking,
    getBookingDuration as api_bookings_multi_service_getBookingDuration
} from "~backend/bookings/multi_service";
import { requestReschedule as api_bookings_request_reschedule_requestReschedule } from "~backend/bookings/request_reschedule";
import { respondReschedule as api_bookings_respond_reschedule_respondReschedule } from "~backend/bookings/respond_reschedule";
import {
    getSharedBooking as api_bookings_share_getSharedBooking,
    revokeBookingShare as api_bookings_share_revokeBookingShare,
    shareBooking as api_bookings_share_shareBooking
} from "~backend/bookings/share";

export namespace bookings {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.accept = this.accept.bind(this)
            this.cancel = this.cancel.bind(this)
            this.create = this.create.bind(this)
            this.createMultiServiceBooking = this.createMultiServiceBooking.bind(this)
            this.decline = this.decline.bind(this)
            this.get = this.get.bind(this)
            this.getBookingDuration = this.getBookingDuration.bind(this)
            this.getDashboardStats = this.getDashboardStats.bind(this)
            this.getSharedBooking = this.getSharedBooking.bind(this)
            this.getSlots = this.getSlots.bind(this)
            this.list = this.list.bind(this)
            this.listRescheduleRequests = this.listRescheduleRequests.bind(this)
            this.requestReschedule = this.requestReschedule.bind(this)
            this.respondReschedule = this.respondReschedule.bind(this)
            this.revokeBookingShare = this.revokeBookingShare.bind(this)
            this.shareBooking = this.shareBooking.bind(this)
        }

        public async accept(params: { id: number }): Promise<ResponseType<typeof api_bookings_accept_accept>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.id)}/accept`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_accept_accept>
        }

        public async cancel(params: RequestType<typeof api_bookings_cancel_cancel>): Promise<ResponseType<typeof api_bookings_cancel_cancel>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                reason: params.reason,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.id)}/cancel`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_cancel_cancel>
        }

        public async create(params: RequestType<typeof api_bookings_create_create>): Promise<ResponseType<typeof api_bookings_create_create>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_create_create>
        }

        public async createMultiServiceBooking(params: RequestType<typeof api_bookings_multi_service_createMultiServiceBooking>): Promise<ResponseType<typeof api_bookings_multi_service_createMultiServiceBooking>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/multi`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_multi_service_createMultiServiceBooking>
        }

        public async decline(params: RequestType<typeof api_bookings_decline_decline>): Promise<ResponseType<typeof api_bookings_decline_decline>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                reason: params.reason,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.id)}/decline`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_decline_decline>
        }

        public async get(params: { id: number }): Promise<ResponseType<typeof api_bookings_get_get>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_get_get>
        }

        public async getBookingDuration(params: RequestType<typeof api_bookings_multi_service_getBookingDuration>): Promise<ResponseType<typeof api_bookings_multi_service_getBookingDuration>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/calculate-duration`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_multi_service_getBookingDuration>
        }

        public async getDashboardStats(): Promise<ResponseType<typeof api_bookings_get_dashboard_stats_getDashboardStats>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/dashboard-stats`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_get_dashboard_stats_getDashboardStats>
        }

        public async getSharedBooking(params: { shareCode: string }): Promise<ResponseType<typeof api_bookings_share_getSharedBooking>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/shared-booking/${encodeURIComponent(params.shareCode)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_share_getSharedBooking>
        }

        public async getSlots(params: RequestType<typeof api_bookings_get_slots_getSlots>): Promise<ResponseType<typeof api_bookings_get_slots_getSlots>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:      params.date,
                serviceId: String(params.serviceId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/slots`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_get_slots_getSlots>
        }

        public async list(params: RequestType<typeof api_bookings_list_list>): Promise<ResponseType<typeof api_bookings_list_list>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:  params.limit === undefined ? undefined : String(params.limit),
                page:   params.page === undefined ? undefined : String(params.page),
                role:   params.role === undefined ? undefined : String(params.role),
                status: params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_list_list>
        }

        public async listRescheduleRequests(): Promise<ResponseType<typeof api_bookings_list_reschedule_requests_listRescheduleRequests>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/reschedule/requests`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_list_reschedule_requests_listRescheduleRequests>
        }

        public async requestReschedule(params: RequestType<typeof api_bookings_request_reschedule_requestReschedule>): Promise<ResponseType<typeof api_bookings_request_reschedule_requestReschedule>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                newEndTime:   params.newEndTime,
                newStartTime: params.newStartTime,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.bookingId)}/reschedule/request`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_request_reschedule_requestReschedule>
        }

        public async respondReschedule(params: RequestType<typeof api_bookings_respond_reschedule_respondReschedule>): Promise<ResponseType<typeof api_bookings_respond_reschedule_respondReschedule>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                accept: params.accept,
                note:   params.note,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/reschedule/${encodeURIComponent(params.rescheduleRequestId)}/respond`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_respond_reschedule_respondReschedule>
        }

        public async revokeBookingShare(params: RequestType<typeof api_bookings_share_revokeBookingShare>): Promise<ResponseType<typeof api_bookings_share_revokeBookingShare>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                shareCode: params.shareCode,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.bookingId)}/share/revoke`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_share_revokeBookingShare>
        }

        public async shareBooking(params: RequestType<typeof api_bookings_share_shareBooking>): Promise<ResponseType<typeof api_bookings_share_shareBooking>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                expiresInHours: params.expiresInHours,
                recipientEmail: params.recipientEmail,
                recipientName:  params.recipientName,
                recipientPhone: params.recipientPhone,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.bookingId)}/share`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_bookings_share_shareBooking>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { createFAQ as api_content_create_faq_createFAQ } from "~backend/content/create_faq";
import { createPage as api_content_create_page_createPage } from "~backend/content/create_page";
import { createSafetyResource as api_content_create_safety_resource_createSafetyResource } from "~backend/content/create_safety_resource";
import { deleteFAQ as api_content_delete_faq_deleteFAQ } from "~backend/content/delete_faq";
import { deletePage as api_content_delete_page_deletePage } from "~backend/content/delete_page";
import { deleteSafetyResource as api_content_delete_safety_resource_deleteSafetyResource } from "~backend/content/delete_safety_resource";
import { getPage as api_content_get_page_getPage } from "~backend/content/get_page";
import { listFAQs as api_content_list_faqs_listFAQs } from "~backend/content/list_faqs";
import { listPages as api_content_list_pages_listPages } from "~backend/content/list_pages";
import { listSafetyResources as api_content_list_safety_resources_listSafetyResources } from "~backend/content/list_safety_resources";
import { updateFAQ as api_content_update_faq_updateFAQ } from "~backend/content/update_faq";
import { updatePage as api_content_update_page_updatePage } from "~backend/content/update_page";
import { updateSafetyResource as api_content_update_safety_resource_updateSafetyResource } from "~backend/content/update_safety_resource";

export namespace content {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.createFAQ = this.createFAQ.bind(this)
            this.createPage = this.createPage.bind(this)
            this.createSafetyResource = this.createSafetyResource.bind(this)
            this.deleteFAQ = this.deleteFAQ.bind(this)
            this.deletePage = this.deletePage.bind(this)
            this.deleteSafetyResource = this.deleteSafetyResource.bind(this)
            this.getPage = this.getPage.bind(this)
            this.listFAQs = this.listFAQs.bind(this)
            this.listPages = this.listPages.bind(this)
            this.listSafetyResources = this.listSafetyResources.bind(this)
            this.updateFAQ = this.updateFAQ.bind(this)
            this.updatePage = this.updatePage.bind(this)
            this.updateSafetyResource = this.updateSafetyResource.bind(this)
        }

        public async createFAQ(params: RequestType<typeof api_content_create_faq_createFAQ>): Promise<ResponseType<typeof api_content_create_faq_createFAQ>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/faqs`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_create_faq_createFAQ>
        }

        public async createPage(params: RequestType<typeof api_content_create_page_createPage>): Promise<ResponseType<typeof api_content_create_page_createPage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/pages`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_create_page_createPage>
        }

        public async createSafetyResource(params: RequestType<typeof api_content_create_safety_resource_createSafetyResource>): Promise<ResponseType<typeof api_content_create_safety_resource_createSafetyResource>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/safety-resources`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_create_safety_resource_createSafetyResource>
        }

        public async deleteFAQ(params: { id: string }): Promise<ResponseType<typeof api_content_delete_faq_deleteFAQ>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/faqs/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_delete_faq_deleteFAQ>
        }

        public async deletePage(params: { id: string }): Promise<ResponseType<typeof api_content_delete_page_deletePage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/pages/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_delete_page_deletePage>
        }

        public async deleteSafetyResource(params: { id: string }): Promise<ResponseType<typeof api_content_delete_safety_resource_deleteSafetyResource>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/safety-resources/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_delete_safety_resource_deleteSafetyResource>
        }

        public async getPage(params: { slug: string }): Promise<ResponseType<typeof api_content_get_page_getPage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/content/pages/${encodeURIComponent(params.slug)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_get_page_getPage>
        }

        public async listFAQs(params: RequestType<typeof api_content_list_faqs_listFAQs>): Promise<ResponseType<typeof api_content_list_faqs_listFAQs>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                activeOnly: params.activeOnly === undefined ? undefined : String(params.activeOnly),
                category:   params.category,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/content/faqs`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_list_faqs_listFAQs>
        }

        public async listPages(params: RequestType<typeof api_content_list_pages_listPages>): Promise<ResponseType<typeof api_content_list_pages_listPages>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:      params.category,
                publishedOnly: params.publishedOnly === undefined ? undefined : String(params.publishedOnly),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/content/pages`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_list_pages_listPages>
        }

        public async listSafetyResources(params: RequestType<typeof api_content_list_safety_resources_listSafetyResources>): Promise<ResponseType<typeof api_content_list_safety_resources_listSafetyResources>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                activeOnly:   params.activeOnly === undefined ? undefined : String(params.activeOnly),
                resourceType: params.resourceType,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/content/safety-resources`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_list_safety_resources_listSafetyResources>
        }

        public async updateFAQ(params: RequestType<typeof api_content_update_faq_updateFAQ>): Promise<ResponseType<typeof api_content_update_faq_updateFAQ>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                answer:       params.answer,
                category:     params.category,
                displayOrder: params.displayOrder,
                isActive:     params.isActive,
                question:     params.question,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/faqs/${encodeURIComponent(params.id)}`, {method: "PATCH", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_update_faq_updateFAQ>
        }

        public async updatePage(params: RequestType<typeof api_content_update_page_updatePage>): Promise<ResponseType<typeof api_content_update_page_updatePage>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                category:        params.category,
                content:         params.content,
                isPublished:     params.isPublished,
                metaDescription: params.metaDescription,
                title:           params.title,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/pages/${encodeURIComponent(params.id)}`, {method: "PATCH", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_update_page_updatePage>
        }

        public async updateSafetyResource(params: RequestType<typeof api_content_update_safety_resource_updateSafetyResource>): Promise<ResponseType<typeof api_content_update_safety_resource_updateSafetyResource>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                description:  params.description,
                displayOrder: params.displayOrder,
                isActive:     params.isActive,
                isEmergency:  params.isEmergency,
                phoneNumber:  params.phoneNumber,
                resourceType: params.resourceType,
                title:        params.title,
                url:          params.url,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/content/safety-resources/${encodeURIComponent(params.id)}`, {method: "PATCH", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_content_update_safety_resource_updateSafetyResource>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { create as api_coupons_create_create } from "~backend/coupons/create";
import { list as api_coupons_list_list } from "~backend/coupons/list";
import { update as api_coupons_update_update } from "~backend/coupons/update";
import { validate as api_coupons_validate_validate } from "~backend/coupons/validate";

export namespace coupons {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.list = this.list.bind(this)
            this.update = this.update.bind(this)
            this.validate = this.validate.bind(this)
        }

        public async create(params: RequestType<typeof api_coupons_create_create>): Promise<ResponseType<typeof api_coupons_create_create>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/coupons`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_coupons_create_create>
        }

        public async list(params: RequestType<typeof api_coupons_list_list>): Promise<ResponseType<typeof api_coupons_list_list>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                isActive: params.isActive === undefined ? undefined : String(params.isActive),
                limit:    params.limit === undefined ? undefined : String(params.limit),
                page:     params.page === undefined ? undefined : String(params.page),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/coupons`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_coupons_list_list>
        }

        public async update(params: RequestType<typeof api_coupons_update_update>): Promise<ResponseType<typeof api_coupons_update_update>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                isActive:   params.isActive,
                notes:      params.notes,
                usageLimit: params.usageLimit,
                validUntil: params.validUntil,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/coupons/${encodeURIComponent(params.id)}`, {method: "PATCH", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_coupons_update_update>
        }

        public async validate(params: RequestType<typeof api_coupons_validate_validate>): Promise<ResponseType<typeof api_coupons_validate_validate>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/coupons/validate`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_coupons_validate_validate>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { adminAddNote as api_disputes_admin_add_note_adminAddNote } from "~backend/disputes/admin_add_note";
import {
    getDashboardStats as api_disputes_admin_dashboard_getDashboardStats,
    getDisputeDetails as api_disputes_admin_dashboard_getDisputeDetails
} from "~backend/disputes/admin_dashboard";
import { adminGet as api_disputes_admin_get_adminGet } from "~backend/disputes/admin_get";
import { adminList as api_disputes_admin_list_adminList } from "~backend/disputes/admin_list";
import { adminResolve as api_disputes_admin_resolve_adminResolve } from "~backend/disputes/admin_resolve";
import { adminUpdateStatus as api_disputes_admin_update_status_adminUpdateStatus } from "~backend/disputes/admin_update_status";
import { create as api_disputes_create_create } from "~backend/disputes/create";
import { get as api_disputes_get_get } from "~backend/disputes/get";
import { listByBooking as api_disputes_list_by_booking_listByBooking } from "~backend/disputes/list_by_booking";
import { uploadAttachment as api_disputes_upload_attachment_uploadAttachment } from "~backend/disputes/upload_attachment";

export namespace disputes {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.adminAddNote = this.adminAddNote.bind(this)
            this.adminGet = this.adminGet.bind(this)
            this.adminList = this.adminList.bind(this)
            this.adminResolve = this.adminResolve.bind(this)
            this.adminUpdateStatus = this.adminUpdateStatus.bind(this)
            this.create = this.create.bind(this)
            this.get = this.get.bind(this)
            this.getDashboardStats = this.getDashboardStats.bind(this)
            this.getDisputeDetails = this.getDisputeDetails.bind(this)
            this.listByBooking = this.listByBooking.bind(this)
            this.uploadAttachment = this.uploadAttachment.bind(this)
        }

        public async adminAddNote(params: RequestType<typeof api_disputes_admin_add_note_adminAddNote>): Promise<ResponseType<typeof api_disputes_admin_add_note_adminAddNote>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                note: params.note,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/disputes/${encodeURIComponent(params.dispute_id)}/notes`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_admin_add_note_adminAddNote>
        }

        public async adminGet(params: { dispute_id: string }): Promise<ResponseType<typeof api_disputes_admin_get_adminGet>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/disputes/${encodeURIComponent(params.dispute_id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_admin_get_adminGet>
        }

        public async adminList(params: RequestType<typeof api_disputes_admin_list_adminList>): Promise<ResponseType<typeof api_disputes_admin_list_adminList>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:  params.limit === undefined ? undefined : String(params.limit),
                offset: params.offset === undefined ? undefined : String(params.offset),
                status: params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/disputes`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_admin_list_adminList>
        }

        public async adminResolve(params: RequestType<typeof api_disputes_admin_resolve_adminResolve>): Promise<ResponseType<typeof api_disputes_admin_resolve_adminResolve>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                "resolution_amount": params["resolution_amount"],
                "resolution_notes":  params["resolution_notes"],
                "resolution_type":   params["resolution_type"],
                "suspend_user_id":   params["suspend_user_id"],
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/disputes/${encodeURIComponent(params.dispute_id)}/resolve`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_admin_resolve_adminResolve>
        }

        public async adminUpdateStatus(params: RequestType<typeof api_disputes_admin_update_status_adminUpdateStatus>): Promise<ResponseType<typeof api_disputes_admin_update_status_adminUpdateStatus>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                status: params.status,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/disputes/${encodeURIComponent(params.dispute_id)}/status`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_admin_update_status_adminUpdateStatus>
        }

        public async create(params: RequestType<typeof api_disputes_create_create>): Promise<ResponseType<typeof api_disputes_create_create>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/disputes`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_create_create>
        }

        public async get(params: { dispute_id: string }): Promise<ResponseType<typeof api_disputes_get_get>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/disputes/${encodeURIComponent(params.dispute_id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_get_get>
        }

        /**
         * Get dispute dashboard statistics
         */
        public async getDashboardStats(): Promise<ResponseType<typeof api_disputes_admin_dashboard_getDashboardStats>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/disputes/stats`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_admin_dashboard_getDashboardStats>
        }

        /**
         * Get detailed dispute view for admin
         */
        public async getDisputeDetails(params: { id: string }): Promise<ResponseType<typeof api_disputes_admin_dashboard_getDisputeDetails>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/disputes/${encodeURIComponent(params.id)}/details`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_admin_dashboard_getDisputeDetails>
        }

        public async listByBooking(params: { booking_id: string }): Promise<ResponseType<typeof api_disputes_list_by_booking_listByBooking>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/bookings/${encodeURIComponent(params.booking_id)}/disputes`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_list_by_booking_listByBooking>
        }

        public async uploadAttachment(params: RequestType<typeof api_disputes_upload_attachment_uploadAttachment>): Promise<ResponseType<typeof api_disputes_upload_attachment_uploadAttachment>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                "content_type": params["content_type"],
                "file_name":    params["file_name"],
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/disputes/${encodeURIComponent(params.dispute_id)}/attachments`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_disputes_upload_attachment_uploadAttachment>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { checkFavorite as api_favorites_check_favorite_checkFavorite } from "~backend/favorites/check_favorite";
import { listFavoriteFreelancers as api_favorites_list_freelancers_listFavoriteFreelancers } from "~backend/favorites/list_freelancers";
import { toggleFavoriteFreelancer as api_favorites_toggle_freelancer_toggleFavoriteFreelancer } from "~backend/favorites/toggle_freelancer";

export namespace favorites {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.checkFavorite = this.checkFavorite.bind(this)
            this.listFavoriteFreelancers = this.listFavoriteFreelancers.bind(this)
            this.toggleFavoriteFreelancer = this.toggleFavoriteFreelancer.bind(this)
        }

        public async checkFavorite(params: { freelancerId: string }): Promise<ResponseType<typeof api_favorites_check_favorite_checkFavorite>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/favorites/freelancers/${encodeURIComponent(params.freelancerId)}/check`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_favorites_check_favorite_checkFavorite>
        }

        public async listFavoriteFreelancers(): Promise<ResponseType<typeof api_favorites_list_freelancers_listFavoriteFreelancers>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/favorites/freelancers`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_favorites_list_freelancers_listFavoriteFreelancers>
        }

        public async toggleFavoriteFreelancer(params: RequestType<typeof api_favorites_toggle_freelancer_toggleFavoriteFreelancer>): Promise<ResponseType<typeof api_favorites_toggle_freelancer_toggleFavoriteFreelancer>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/favorites/freelancers/toggle`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_favorites_toggle_freelancer_toggleFavoriteFreelancer>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { get as api_freelancers_get_get } from "~backend/freelancers/get";
import { list as api_freelancers_list_list } from "~backend/freelancers/list";

export namespace freelancers {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.get = this.get.bind(this)
            this.list = this.list.bind(this)
        }

        /**
         * Retrieves a specific freelancer profile
         */
        public async get(params: { id: string }): Promise<ResponseType<typeof api_freelancers_get_get>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/freelancers/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_freelancers_get_get>
        }

        /**
         * Lists all verified freelancers
         */
        public async list(): Promise<ResponseType<typeof api_freelancers_list_list>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/freelancers`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_freelancers_list_list>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { check as api_health_check_check } from "~backend/health/check";

export namespace health {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.check = this.check.bind(this)
        }

        /**
         * Health check endpoint
         */
        public async check(): Promise<ResponseType<typeof api_health_check_check>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/health`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_health_check_check>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { getLoyaltyStatus as api_loyalty_get_status_getLoyaltyStatus } from "~backend/loyalty/get_status";

export namespace loyalty {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getLoyaltyStatus = this.getLoyaltyStatus.bind(this)
        }

        public async getLoyaltyStatus(): Promise<ResponseType<typeof api_loyalty_get_status_getLoyaltyStatus>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/loyalty/status`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_loyalty_get_status_getLoyaltyStatus>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { createConversation as api_messages_create_conversation_createConversation } from "~backend/messages/create_conversation";
import { getMessages as api_messages_get_messages_getMessages } from "~backend/messages/get_messages";
import { listConversations as api_messages_list_conversations_listConversations } from "~backend/messages/list_conversations";
import { sendMessage as api_messages_send_message_sendMessage } from "~backend/messages/send_message";

export namespace messages {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.createConversation = this.createConversation.bind(this)
            this.getMessages = this.getMessages.bind(this)
            this.listConversations = this.listConversations.bind(this)
            this.sendMessage = this.sendMessage.bind(this)
        }

        public async createConversation(params: RequestType<typeof api_messages_create_conversation_createConversation>): Promise<ResponseType<typeof api_messages_create_conversation_createConversation>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/messages/conversations`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_messages_create_conversation_createConversation>
        }

        public async getMessages(params: RequestType<typeof api_messages_get_messages_getMessages>): Promise<ResponseType<typeof api_messages_get_messages_getMessages>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                before: params.before === undefined ? undefined : String(params.before),
                limit:  params.limit === undefined ? undefined : String(params.limit),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/messages/conversations/${encodeURIComponent(params.conversationId)}`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_messages_get_messages_getMessages>
        }

        public async listConversations(): Promise<ResponseType<typeof api_messages_list_conversations_listConversations>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/messages/conversations`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_messages_list_conversations_listConversations>
        }

        public async sendMessage(params: RequestType<typeof api_messages_send_message_sendMessage>): Promise<ResponseType<typeof api_messages_send_message_sendMessage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/messages/send`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_messages_send_message_sendMessage>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { clearRead as api_notifications_clear_read_clearRead } from "~backend/notifications/clear_read";
import { getPreferences as api_notifications_get_preferences_getPreferences } from "~backend/notifications/get_preferences";
import { list as api_notifications_list_list } from "~backend/notifications/list";
import { listPaginated as api_notifications_list_paginated_listPaginated } from "~backend/notifications/list_paginated";
import { markRead as api_notifications_mark_read_markRead } from "~backend/notifications/mark_read";
import { stream as api_notifications_stream_stream } from "~backend/notifications/stream";
import { updatePreferences as api_notifications_update_preferences_updatePreferences } from "~backend/notifications/update_preferences";

export namespace notifications {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.clearRead = this.clearRead.bind(this)
            this.getPreferences = this.getPreferences.bind(this)
            this.list = this.list.bind(this)
            this.listPaginated = this.listPaginated.bind(this)
            this.markAllRead = this.markAllRead.bind(this)
            this.markRead = this.markRead.bind(this)
            this.stream = this.stream.bind(this)
            this.updatePreferences = this.updatePreferences.bind(this)
        }

        public async clearRead(): Promise<ResponseType<typeof api_notifications_clear_read_clearRead>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/notifications/read`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_notifications_clear_read_clearRead>
        }

        public async getPreferences(): Promise<ResponseType<typeof api_notifications_get_preferences_getPreferences>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/notifications/preferences`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_notifications_get_preferences_getPreferences>
        }

        public async list(): Promise<ResponseType<typeof api_notifications_list_list>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/notifications`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_notifications_list_list>
        }

        public async listPaginated(params: RequestType<typeof api_notifications_list_paginated_listPaginated>): Promise<ResponseType<typeof api_notifications_list_paginated_listPaginated>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                type:       params.type === undefined ? undefined : String(params.type),
                unreadOnly: params.unreadOnly === undefined ? undefined : String(params.unreadOnly),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/notifications/paginated`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_notifications_list_paginated_listPaginated>
        }

        public async markAllRead(): Promise<void> {
            await this.baseClient.callTypedAPI(`/notifications/mark-all-read`, {method: "POST", body: undefined})
        }

        public async markRead(params: { notification_id: number }): Promise<void> {
            await this.baseClient.callTypedAPI(`/notifications/${encodeURIComponent(params.notification_id)}/read`, {method: "POST", body: undefined})
        }

        public async stream(): Promise<StreamIn<StreamResponse<typeof api_notifications_stream_stream>>> {
            return await this.baseClient.createStreamIn(`/notifications/stream`)
        }

        public async updatePreferences(params: RequestType<typeof api_notifications_update_preferences_updatePreferences>): Promise<ResponseType<typeof api_notifications_update_preferences_updatePreferences>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/notifications/preferences`, {method: "PUT", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_notifications_update_preferences_updatePreferences>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { createPackage as api_packages_create_createPackage } from "~backend/packages/create";
import { deletePackage as api_packages_delete_deletePackage } from "~backend/packages/delete";
import { getPackage as api_packages_get_getPackage } from "~backend/packages/get";
import { listPackages as api_packages_list_listPackages } from "~backend/packages/list";
import { updatePackage as api_packages_update_updatePackage } from "~backend/packages/update";

export namespace packages {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.createPackage = this.createPackage.bind(this)
            this.deletePackage = this.deletePackage.bind(this)
            this.getPackage = this.getPackage.bind(this)
            this.listPackages = this.listPackages.bind(this)
            this.updatePackage = this.updatePackage.bind(this)
        }

        public async createPackage(params: RequestType<typeof api_packages_create_createPackage>): Promise<ResponseType<typeof api_packages_create_createPackage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/packages`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_packages_create_createPackage>
        }

        public async deletePackage(params: { id: number }): Promise<ResponseType<typeof api_packages_delete_deletePackage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/packages/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_packages_delete_deletePackage>
        }

        public async getPackage(params: { id: number }): Promise<ResponseType<typeof api_packages_get_getPackage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/packages/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_packages_get_getPackage>
        }

        public async listPackages(params: RequestType<typeof api_packages_list_listPackages>): Promise<ResponseType<typeof api_packages_list_listPackages>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                activeOnly:   params.activeOnly === undefined ? undefined : String(params.activeOnly),
                freelancerId: params.freelancerId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/packages`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_packages_list_listPackages>
        }

        public async updatePackage(params: RequestType<typeof api_packages_update_updatePackage>): Promise<ResponseType<typeof api_packages_update_updatePackage>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                description:         params.description,
                discountAmountPence: params.discountAmountPence,
                discountPercent:     params.discountPercent,
                imageUrl:            params.imageUrl,
                isActive:            params.isActive,
                maxUses:             params.maxUses,
                name:                params.name,
                serviceIds:          params.serviceIds,
                validUntil:          params.validUntil,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/packages/${encodeURIComponent(params.id)}`, {method: "PUT", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_packages_update_updatePackage>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { confirmService as api_payments_confirm_service_confirmService } from "~backend/payments/confirm_service";
import { createCheckout as api_payments_create_checkout_createCheckout } from "~backend/payments/create_checkout";
import { getStatus as api_payments_get_status_getStatus } from "~backend/payments/get_status";
import { refund as api_payments_refund_refund } from "~backend/payments/refund";

export namespace payments {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.confirmService = this.confirmService.bind(this)
            this.createCheckout = this.createCheckout.bind(this)
            this.getStatus = this.getStatus.bind(this)
            this.refund = this.refund.bind(this)
            this.webhook = this.webhook.bind(this)
        }

        public async confirmService(params: { bookingId: number }): Promise<ResponseType<typeof api_payments_confirm_service_confirmService>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payments/${encodeURIComponent(params.bookingId)}/confirm`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payments_confirm_service_confirmService>
        }

        public async createCheckout(params: RequestType<typeof api_payments_create_checkout_createCheckout>): Promise<ResponseType<typeof api_payments_create_checkout_createCheckout>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payments/checkout`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payments_create_checkout_createCheckout>
        }

        public async getStatus(params: { bookingId: number }): Promise<ResponseType<typeof api_payments_get_status_getStatus>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payments/${encodeURIComponent(params.bookingId)}/status`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payments_get_status_getStatus>
        }

        public async refund(params: RequestType<typeof api_payments_refund_refund>): Promise<ResponseType<typeof api_payments_refund_refund>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payments/refund`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payments_refund_refund>
        }

        public async webhook(options: PickMethods<"POST"> = {}): Promise<globalThis.Response> {
            options.method ||= "POST";
            return this.baseClient.callAPI(`/payments/webhook`, options)
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { adminGetPayout as api_payouts_admin_get_payout_adminGetPayout } from "~backend/payouts/admin_get_payout";
import { adminGetSettings as api_payouts_admin_get_settings_adminGetSettings } from "~backend/payouts/admin_get_settings";
import { adminListPayouts as api_payouts_admin_list_payouts_adminListPayouts } from "~backend/payouts/admin_list_payouts";
import { adminOverridePayout as api_payouts_admin_override_payout_adminOverridePayout } from "~backend/payouts/admin_override_payout";
import { adminUpdateSettings as api_payouts_admin_update_settings_adminUpdateSettings } from "~backend/payouts/admin_update_settings";
import { createAccount as api_payouts_create_account_createAccount } from "~backend/payouts/create_account";
import { getAccount as api_payouts_get_account_getAccount } from "~backend/payouts/get_account";
import { getEarnings as api_payouts_get_earnings_getEarnings } from "~backend/payouts/get_earnings";
import { getHistory as api_payouts_get_history_getHistory } from "~backend/payouts/get_history";
import { refreshAccountStatus as api_payouts_refresh_account_status_refreshAccountStatus } from "~backend/payouts/refresh_account_status";
import { setSchedule as api_payouts_set_schedule_setSchedule } from "~backend/payouts/set_schedule";

export namespace payouts {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.adminGetPayout = this.adminGetPayout.bind(this)
            this.adminGetSettings = this.adminGetSettings.bind(this)
            this.adminListPayouts = this.adminListPayouts.bind(this)
            this.adminOverridePayout = this.adminOverridePayout.bind(this)
            this.adminUpdateSettings = this.adminUpdateSettings.bind(this)
            this.createAccount = this.createAccount.bind(this)
            this.getAccount = this.getAccount.bind(this)
            this.getEarnings = this.getEarnings.bind(this)
            this.getHistory = this.getHistory.bind(this)
            this.refreshAccountStatus = this.refreshAccountStatus.bind(this)
            this.setSchedule = this.setSchedule.bind(this)
        }

        public async adminGetPayout(params: { id: number }): Promise<ResponseType<typeof api_payouts_admin_get_payout_adminGetPayout>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/payouts/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_admin_get_payout_adminGetPayout>
        }

        public async adminGetSettings(): Promise<ResponseType<typeof api_payouts_admin_get_settings_adminGetSettings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/payouts/settings`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_admin_get_settings_adminGetSettings>
        }

        public async adminListPayouts(params: RequestType<typeof api_payouts_admin_list_payouts_adminListPayouts>): Promise<ResponseType<typeof api_payouts_admin_list_payouts_adminListPayouts>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                freelancerId: params.freelancerId === undefined ? undefined : String(params.freelancerId),
                limit:        params.limit === undefined ? undefined : String(params.limit),
                page:         params.page === undefined ? undefined : String(params.page),
                status:       params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/payouts`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_admin_list_payouts_adminListPayouts>
        }

        public async adminOverridePayout(params: RequestType<typeof api_payouts_admin_override_payout_adminOverridePayout>): Promise<ResponseType<typeof api_payouts_admin_override_payout_adminOverridePayout>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                adminNotes: params.adminNotes,
                status:     params.status,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/payouts/${encodeURIComponent(params.id)}/override`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_admin_override_payout_adminOverridePayout>
        }

        public async adminUpdateSettings(params: RequestType<typeof api_payouts_admin_update_settings_adminUpdateSettings>): Promise<ResponseType<typeof api_payouts_admin_update_settings_adminUpdateSettings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/payouts/settings`, {method: "PUT", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_admin_update_settings_adminUpdateSettings>
        }

        public async createAccount(params: RequestType<typeof api_payouts_create_account_createAccount>): Promise<ResponseType<typeof api_payouts_create_account_createAccount>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payouts/account`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_create_account_createAccount>
        }

        public async getAccount(): Promise<ResponseType<typeof api_payouts_get_account_getAccount>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payouts/account`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_get_account_getAccount>
        }

        public async getEarnings(): Promise<ResponseType<typeof api_payouts_get_earnings_getEarnings>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payouts/earnings`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_get_earnings_getEarnings>
        }

        public async getHistory(params: RequestType<typeof api_payouts_get_history_getHistory>): Promise<ResponseType<typeof api_payouts_get_history_getHistory>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:  params.limit === undefined ? undefined : String(params.limit),
                page:   params.page === undefined ? undefined : String(params.page),
                status: params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payouts/history`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_get_history_getHistory>
        }

        public async refreshAccountStatus(): Promise<ResponseType<typeof api_payouts_refresh_account_status_refreshAccountStatus>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payouts/account/refresh`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_refresh_account_status_refreshAccountStatus>
        }

        public async setSchedule(params: RequestType<typeof api_payouts_set_schedule_setSchedule>): Promise<ResponseType<typeof api_payouts_set_schedule_setSchedule>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/payouts/schedule`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_payouts_set_schedule_setSchedule>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { getFreelancerReliability as api_policies_get_freelancer_reliability_getFreelancerReliability } from "~backend/policies/get_freelancer_reliability";
import { getPolicies as api_policies_get_policies_getPolicies } from "~backend/policies/get_policies";
import { getReliabilityConfigEndpoint as api_policies_get_reliability_config_getReliabilityConfigEndpoint } from "~backend/policies/get_reliability_config";
import { updatePolicies as api_policies_update_policies_updatePolicies } from "~backend/policies/update_policies";
import { updateReliabilityConfigEndpoint as api_policies_update_reliability_config_updateReliabilityConfigEndpoint } from "~backend/policies/update_reliability_config";

export namespace policies {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getFreelancerReliability = this.getFreelancerReliability.bind(this)
            this.getPolicies = this.getPolicies.bind(this)
            this.getReliabilityConfigEndpoint = this.getReliabilityConfigEndpoint.bind(this)
            this.updatePolicies = this.updatePolicies.bind(this)
            this.updateReliabilityConfigEndpoint = this.updateReliabilityConfigEndpoint.bind(this)
        }

        public async getFreelancerReliability(params: RequestType<typeof api_policies_get_freelancer_reliability_getFreelancerReliability>): Promise<ResponseType<typeof api_policies_get_freelancer_reliability_getFreelancerReliability>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                freelancerId: params.freelancerId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/policies/reliability/freelancer`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_policies_get_freelancer_reliability_getFreelancerReliability>
        }

        public async getPolicies(): Promise<ResponseType<typeof api_policies_get_policies_getPolicies>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/policies/cancellation`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_policies_get_policies_getPolicies>
        }

        public async getReliabilityConfigEndpoint(): Promise<ResponseType<typeof api_policies_get_reliability_config_getReliabilityConfigEndpoint>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/policies/reliability`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_policies_get_reliability_config_getReliabilityConfigEndpoint>
        }

        public async updatePolicies(params: RequestType<typeof api_policies_update_policies_updatePolicies>): Promise<ResponseType<typeof api_policies_update_policies_updatePolicies>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/policies/cancellation`, {method: "PUT", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_policies_update_policies_updatePolicies>
        }

        public async updateReliabilityConfigEndpoint(params: RequestType<typeof api_policies_update_reliability_config_updateReliabilityConfigEndpoint>): Promise<ResponseType<typeof api_policies_update_reliability_config_updateReliabilityConfigEndpoint>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/policies/reliability`, {method: "PUT", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_policies_update_reliability_config_updateReliabilityConfigEndpoint>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { confirmProfilePhoto as api_profiles_confirm_profile_photo_confirmProfilePhoto } from "~backend/profiles/confirm_profile_photo";
import { deletePortfolioItem as api_profiles_delete_portfolio_item_deletePortfolioItem } from "~backend/profiles/delete_portfolio_item";
import { getProfile as api_profiles_get_profile_getProfile } from "~backend/profiles/get_profile";
import { listPortfolio as api_profiles_list_portfolio_listPortfolio } from "~backend/profiles/list_portfolio";
import { savePortfolioItem as api_profiles_save_portfolio_item_savePortfolioItem } from "~backend/profiles/save_portfolio_item";
import { updateProfile as api_profiles_update_profile_updateProfile } from "~backend/profiles/update_profile";
import { uploadPortfolioImage as api_profiles_upload_portfolio_image_uploadPortfolioImage } from "~backend/profiles/upload_portfolio_image";
import { uploadProfilePhoto as api_profiles_upload_profile_photo_uploadProfilePhoto } from "~backend/profiles/upload_profile_photo";

export namespace profiles {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.confirmProfilePhoto = this.confirmProfilePhoto.bind(this)
            this.deletePortfolioItem = this.deletePortfolioItem.bind(this)
            this.getProfile = this.getProfile.bind(this)
            this.listPortfolio = this.listPortfolio.bind(this)
            this.savePortfolioItem = this.savePortfolioItem.bind(this)
            this.updateProfile = this.updateProfile.bind(this)
            this.uploadPortfolioImage = this.uploadPortfolioImage.bind(this)
            this.uploadProfilePhoto = this.uploadProfilePhoto.bind(this)
        }

        public async confirmProfilePhoto(params: RequestType<typeof api_profiles_confirm_profile_photo_confirmProfilePhoto>): Promise<ResponseType<typeof api_profiles_confirm_profile_photo_confirmProfilePhoto>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/photo/confirm`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_confirm_profile_photo_confirmProfilePhoto>
        }

        public async deletePortfolioItem(params: { itemId: number }): Promise<ResponseType<typeof api_profiles_delete_portfolio_item_deletePortfolioItem>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/portfolio/${encodeURIComponent(params.itemId)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_delete_portfolio_item_deletePortfolioItem>
        }

        public async getProfile(params: { userId: string }): Promise<ResponseType<typeof api_profiles_get_profile_getProfile>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/${encodeURIComponent(params.userId)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_get_profile_getProfile>
        }

        public async listPortfolio(params: { userId: string }): Promise<ResponseType<typeof api_profiles_list_portfolio_listPortfolio>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/${encodeURIComponent(params.userId)}/portfolio`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_list_portfolio_listPortfolio>
        }

        public async savePortfolioItem(params: RequestType<typeof api_profiles_save_portfolio_item_savePortfolioItem>): Promise<ResponseType<typeof api_profiles_save_portfolio_item_savePortfolioItem>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/portfolio`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_save_portfolio_item_savePortfolioItem>
        }

        public async updateProfile(params: RequestType<typeof api_profiles_update_profile_updateProfile>): Promise<ResponseType<typeof api_profiles_update_profile_updateProfile>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/me`, {method: "PUT", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_update_profile_updateProfile>
        }

        public async uploadPortfolioImage(): Promise<ResponseType<typeof api_profiles_upload_portfolio_image_uploadPortfolioImage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/portfolio/upload-url`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_upload_portfolio_image_uploadPortfolioImage>
        }

        public async uploadProfilePhoto(): Promise<ResponseType<typeof api_profiles_upload_profile_photo_uploadProfilePhoto>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/profiles/photo/upload-url`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_profiles_upload_profile_photo_uploadProfilePhoto>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { applyReferralCode as api_referrals_apply_code_applyReferralCode } from "~backend/referrals/apply_code";
import { getReferralCode as api_referrals_get_code_getReferralCode } from "~backend/referrals/get_code";
import { listReferrals as api_referrals_list_referrals_listReferrals } from "~backend/referrals/list_referrals";

export namespace referrals {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.applyReferralCode = this.applyReferralCode.bind(this)
            this.getReferralCode = this.getReferralCode.bind(this)
            this.listReferrals = this.listReferrals.bind(this)
        }

        public async applyReferralCode(params: RequestType<typeof api_referrals_apply_code_applyReferralCode>): Promise<ResponseType<typeof api_referrals_apply_code_applyReferralCode>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/referrals/apply`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_referrals_apply_code_applyReferralCode>
        }

        public async getReferralCode(): Promise<ResponseType<typeof api_referrals_get_code_getReferralCode>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/referrals/code`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_referrals_get_code_getReferralCode>
        }

        public async listReferrals(): Promise<ResponseType<typeof api_referrals_list_referrals_listReferrals>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/referrals/list`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_referrals_list_referrals_listReferrals>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { adminAccountAction as api_reports_admin_account_action_adminAccountAction } from "~backend/reports/admin_account_action";
import { adminGet as api_reports_admin_get_adminGet } from "~backend/reports/admin_get";
import { adminList as api_reports_admin_list_adminList } from "~backend/reports/admin_list";
import { adminUpdateStatus as api_reports_admin_update_status_adminUpdateStatus } from "~backend/reports/admin_update_status";
import { submit as api_reports_submit_submit } from "~backend/reports/submit";
import { uploadAttachment as api_reports_upload_attachment_uploadAttachment } from "~backend/reports/upload_attachment";

export namespace reports {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.adminAccountAction = this.adminAccountAction.bind(this)
            this.adminGet = this.adminGet.bind(this)
            this.adminList = this.adminList.bind(this)
            this.adminUpdateStatus = this.adminUpdateStatus.bind(this)
            this.submit = this.submit.bind(this)
            this.uploadAttachment = this.uploadAttachment.bind(this)
        }

        public async adminAccountAction(params: RequestType<typeof api_reports_admin_account_action_adminAccountAction>): Promise<ResponseType<typeof api_reports_admin_account_action_adminAccountAction>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reports/account-action`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reports_admin_account_action_adminAccountAction>
        }

        public async adminGet(params: { id: string }): Promise<ResponseType<typeof api_reports_admin_get_adminGet>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reports/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reports_admin_get_adminGet>
        }

        public async adminList(params: RequestType<typeof api_reports_admin_list_adminList>): Promise<ResponseType<typeof api_reports_admin_list_adminList>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reports/list`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reports_admin_list_adminList>
        }

        public async adminUpdateStatus(params: RequestType<typeof api_reports_admin_update_status_adminUpdateStatus>): Promise<ResponseType<typeof api_reports_admin_update_status_adminUpdateStatus>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reports/update-status`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reports_admin_update_status_adminUpdateStatus>
        }

        public async submit(params: RequestType<typeof api_reports_submit_submit>): Promise<ResponseType<typeof api_reports_submit_submit>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/reports`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reports_submit_submit>
        }

        public async uploadAttachment(params: RequestType<typeof api_reports_upload_attachment_uploadAttachment>): Promise<ResponseType<typeof api_reports_upload_attachment_uploadAttachment>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/reports/upload-attachment`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reports_upload_attachment_uploadAttachment>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { adminGetLogs as api_reviews_admin_get_logs_adminGetLogs } from "~backend/reviews/admin_get_logs";
import { adminListAll as api_reviews_admin_list_all_adminListAll } from "~backend/reviews/admin_list_all";
import { adminRemove as api_reviews_admin_remove_adminRemove } from "~backend/reviews/admin_remove";
import { adminRestore as api_reviews_admin_restore_adminRestore } from "~backend/reviews/admin_restore";
import { create as api_reviews_create_create } from "~backend/reviews/create";
import { getBookingReview as api_reviews_get_booking_review_getBookingReview } from "~backend/reviews/get_booking_review";
import { listByFreelancer as api_reviews_list_by_freelancer_listByFreelancer } from "~backend/reviews/list_by_freelancer";
import { triggerReviewReminders as api_reviews_reminders_triggerReviewReminders } from "~backend/reviews/reminders";
import {
    confirmPhoto as api_reviews_upload_photo_confirmPhoto,
    uploadPhoto as api_reviews_upload_photo_uploadPhoto
} from "~backend/reviews/upload_photo";

export namespace reviews {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.adminGetLogs = this.adminGetLogs.bind(this)
            this.adminListAll = this.adminListAll.bind(this)
            this.adminRemove = this.adminRemove.bind(this)
            this.adminRestore = this.adminRestore.bind(this)
            this.confirmPhoto = this.confirmPhoto.bind(this)
            this.create = this.create.bind(this)
            this.getBookingReview = this.getBookingReview.bind(this)
            this.listByFreelancer = this.listByFreelancer.bind(this)
            this.triggerReviewReminders = this.triggerReviewReminders.bind(this)
            this.uploadPhoto = this.uploadPhoto.bind(this)
        }

        public async adminGetLogs(params: { reviewId: number }): Promise<ResponseType<typeof api_reviews_admin_get_logs_adminGetLogs>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reviews/${encodeURIComponent(params.reviewId)}/logs`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_admin_get_logs_adminGetLogs>
        }

        public async adminListAll(params: RequestType<typeof api_reviews_admin_list_all_adminListAll>): Promise<ResponseType<typeof api_reviews_admin_list_all_adminListAll>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                includeRemoved: params.includeRemoved === undefined ? undefined : String(params.includeRemoved),
                limit:          params.limit === undefined ? undefined : String(params.limit),
                offset:         params.offset === undefined ? undefined : String(params.offset),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reviews`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_admin_list_all_adminListAll>
        }

        public async adminRemove(params: RequestType<typeof api_reviews_admin_remove_adminRemove>): Promise<ResponseType<typeof api_reviews_admin_remove_adminRemove>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                reason: params.reason,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reviews/${encodeURIComponent(params.reviewId)}/remove`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_admin_remove_adminRemove>
        }

        public async adminRestore(params: { reviewId: number }): Promise<ResponseType<typeof api_reviews_admin_restore_adminRestore>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/reviews/${encodeURIComponent(params.reviewId)}/restore`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_admin_restore_adminRestore>
        }

        public async confirmPhoto(params: RequestType<typeof api_reviews_upload_photo_confirmPhoto>): Promise<ResponseType<typeof api_reviews_upload_photo_confirmPhoto>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                photoKey: params.photoKey,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/reviews/${encodeURIComponent(params.reviewId)}/photo/confirm`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_upload_photo_confirmPhoto>
        }

        public async create(params: RequestType<typeof api_reviews_create_create>): Promise<ResponseType<typeof api_reviews_create_create>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/reviews`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_create_create>
        }

        public async getBookingReview(params: { bookingId: number }): Promise<ResponseType<typeof api_reviews_get_booking_review_getBookingReview>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/reviews/booking/${encodeURIComponent(params.bookingId)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_get_booking_review_getBookingReview>
        }

        public async listByFreelancer(params: RequestType<typeof api_reviews_list_by_freelancer_listByFreelancer>): Promise<ResponseType<typeof api_reviews_list_by_freelancer_listByFreelancer>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:  params.limit === undefined ? undefined : String(params.limit),
                offset: params.offset === undefined ? undefined : String(params.offset),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/reviews/freelancer/${encodeURIComponent(params.freelancerId)}`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_list_by_freelancer_listByFreelancer>
        }

        /**
         * Manual trigger for testing
         */
        public async triggerReviewReminders(): Promise<ResponseType<typeof api_reviews_reminders_triggerReviewReminders>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/review-reminders/trigger`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_reminders_triggerReviewReminders>
        }

        public async uploadPhoto(params: { reviewId: number }): Promise<ResponseType<typeof api_reviews_upload_photo_uploadPhoto>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/reviews/${encodeURIComponent(params.reviewId)}/photo/upload-url`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_reviews_upload_photo_uploadPhoto>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import {
    addEmergencyContact as api_safety_emergency_addEmergencyContact,
    deleteEmergencyContact as api_safety_emergency_deleteEmergencyContact,
    getEmergencyInfo as api_safety_emergency_getEmergencyInfo,
    listEmergencyContacts as api_safety_emergency_listEmergencyContacts,
    triggerEmergencyAlert as api_safety_emergency_triggerEmergencyAlert
} from "~backend/safety/emergency";
import {
    getSafetyResource as api_safety_resources_getSafetyResource,
    getSafetyResources as api_safety_resources_getSafetyResources
} from "~backend/safety/resources";

export namespace safety {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addEmergencyContact = this.addEmergencyContact.bind(this)
            this.deleteEmergencyContact = this.deleteEmergencyContact.bind(this)
            this.getEmergencyInfo = this.getEmergencyInfo.bind(this)
            this.getSafetyResource = this.getSafetyResource.bind(this)
            this.getSafetyResources = this.getSafetyResources.bind(this)
            this.listEmergencyContacts = this.listEmergencyContacts.bind(this)
            this.triggerEmergencyAlert = this.triggerEmergencyAlert.bind(this)
        }

        public async addEmergencyContact(params: RequestType<typeof api_safety_emergency_addEmergencyContact>): Promise<ResponseType<typeof api_safety_emergency_addEmergencyContact>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/safety/emergency-contacts`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_safety_emergency_addEmergencyContact>
        }

        public async deleteEmergencyContact(params: { id: number }): Promise<ResponseType<typeof api_safety_emergency_deleteEmergencyContact>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/safety/emergency-contacts/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_safety_emergency_deleteEmergencyContact>
        }

        public async getEmergencyInfo(): Promise<ResponseType<typeof api_safety_emergency_getEmergencyInfo>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/safety/emergency-info`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_safety_emergency_getEmergencyInfo>
        }

        public async getSafetyResource(params: { id: string }): Promise<ResponseType<typeof api_safety_resources_getSafetyResource>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/safety/resources/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_safety_resources_getSafetyResource>
        }

        public async getSafetyResources(): Promise<ResponseType<typeof api_safety_resources_getSafetyResources>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/safety/resources`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_safety_resources_getSafetyResources>
        }

        public async listEmergencyContacts(): Promise<ResponseType<typeof api_safety_emergency_listEmergencyContacts>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/safety/emergency-contacts`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_safety_emergency_listEmergencyContacts>
        }

        public async triggerEmergencyAlert(params: RequestType<typeof api_safety_emergency_triggerEmergencyAlert>): Promise<ResponseType<typeof api_safety_emergency_triggerEmergencyAlert>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/safety/emergency-alert`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_safety_emergency_triggerEmergencyAlert>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { checkAvailability as api_search_availability_checkAvailability } from "~backend/search/availability";
import { search as api_search_search_search } from "~backend/search/search";

export namespace search {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.checkAvailability = this.checkAvailability.bind(this)
            this.search = this.search.bind(this)
        }

        public async checkAvailability(params: RequestType<typeof api_search_availability_checkAvailability>): Promise<ResponseType<typeof api_search_availability_checkAvailability>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:         params.date,
                freelancerId: params.freelancerId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/search/availability`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_search_availability_checkAvailability>
        }

        public async search(params: RequestType<typeof api_search_search_search>): Promise<ResponseType<typeof api_search_search_search>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                availableOnDate:      params.availableOnDate,
                availableThisWeekend: params.availableThisWeekend === undefined ? undefined : String(params.availableThisWeekend),
                category:             params.category,
                dayPattern:           params.dayPattern,
                experienceLevel:      params.experienceLevel,
                keyword:              params.keyword,
                limit:                params.limit === undefined ? undefined : String(params.limit),
                location:             params.location,
                locationType:         params.locationType,
                maxPrice:             params.maxPrice === undefined ? undefined : String(params.maxPrice),
                minPrice:             params.minPrice === undefined ? undefined : String(params.minPrice),
                minRating:            params.minRating === undefined ? undefined : String(params.minRating),
                page:                 params.page === undefined ? undefined : String(params.page),
                radiusMiles:          params.radiusMiles === undefined ? undefined : String(params.radiusMiles),
                sortBy:               params.sortBy,
                specificDays:         params.specificDays,
                timeOfDay:            params.timeOfDay,
                verifiedOnly:         params.verifiedOnly === undefined ? undefined : String(params.verifiedOnly),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/search`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_search_search_search>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { activate as api_services_activate_activate } from "~backend/services/activate";
import { create as api_services_create_create } from "~backend/services/create";
import { deactivate as api_services_deactivate_deactivate } from "~backend/services/deactivate";
import { deleteImage as api_services_delete_image_deleteImage } from "~backend/services/delete_image";
import { duplicate as api_services_duplicate_duplicate } from "~backend/services/duplicate";
import { get as api_services_get_get } from "~backend/services/get";
import { list as api_services_list_list } from "~backend/services/list";
import { listImages as api_services_list_images_listImages } from "~backend/services/list_images";
import { reorderImages as api_services_reorder_images_reorderImages } from "~backend/services/reorder_images";
import {
    getServiceTemplate as api_services_templates_getServiceTemplate,
    getServiceTemplates as api_services_templates_getServiceTemplates
} from "~backend/services/templates";
import { update as api_services_update_update } from "~backend/services/update";
import { uploadImage as api_services_upload_image_uploadImage } from "~backend/services/upload_image";
import {
    deleteVideo as api_services_upload_video_deleteVideo,
    listVideos as api_services_upload_video_listVideos,
    uploadVideo as api_services_upload_video_uploadVideo
} from "~backend/services/upload_video";

export namespace services {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.activate = this.activate.bind(this)
            this.create = this.create.bind(this)
            this.deactivate = this.deactivate.bind(this)
            this.deleteImage = this.deleteImage.bind(this)
            this.deleteVideo = this.deleteVideo.bind(this)
            this.duplicate = this.duplicate.bind(this)
            this.get = this.get.bind(this)
            this.getServiceTemplate = this.getServiceTemplate.bind(this)
            this.getServiceTemplates = this.getServiceTemplates.bind(this)
            this.list = this.list.bind(this)
            this.listImages = this.listImages.bind(this)
            this.listVideos = this.listVideos.bind(this)
            this.reorderImages = this.reorderImages.bind(this)
            this.update = this.update.bind(this)
            this.uploadImage = this.uploadImage.bind(this)
            this.uploadVideo = this.uploadVideo.bind(this)
        }

        public async activate(params: { id: number }): Promise<ResponseType<typeof api_services_activate_activate>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.id)}/activate`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_activate_activate>
        }

        public async create(params: RequestType<typeof api_services_create_create>): Promise<ResponseType<typeof api_services_create_create>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_create_create>
        }

        public async deactivate(params: { id: number }): Promise<ResponseType<typeof api_services_deactivate_deactivate>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.id)}/deactivate`, {method: "POST", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_deactivate_deactivate>
        }

        public async deleteImage(params: { serviceId: number, imageId: number }): Promise<void> {
            await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/images/${encodeURIComponent(params.imageId)}`, {method: "DELETE", body: undefined})
        }

        public async deleteVideo(params: { serviceId: number, videoId: number }): Promise<ResponseType<typeof api_services_upload_video_deleteVideo>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/videos/${encodeURIComponent(params.videoId)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_upload_video_deleteVideo>
        }

        public async duplicate(params: RequestType<typeof api_services_duplicate_duplicate>): Promise<ResponseType<typeof api_services_duplicate_duplicate>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                newTitle: params.newTitle,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/duplicate`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_duplicate_duplicate>
        }

        /**
         * Retrieves detailed information about a specific service
         */
        public async get(params: { id: number }): Promise<ResponseType<typeof api_services_get_get>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_get_get>
        }

        public async getServiceTemplate(params: { name: string }): Promise<ResponseType<typeof api_services_templates_getServiceTemplate>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/templates/${encodeURIComponent(params.name)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_templates_getServiceTemplate>
        }

        public async getServiceTemplates(params: RequestType<typeof api_services_templates_getServiceTemplates>): Promise<ResponseType<typeof api_services_templates_getServiceTemplates>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category: params.category,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/templates`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_templates_getServiceTemplates>
        }

        /**
         * Lists active services with optional filtering by freelancer or category
         */
        public async list(params: RequestType<typeof api_services_list_list>): Promise<ResponseType<typeof api_services_list_list>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:        params.category,
                freelancerId:    params.freelancerId,
                includeInactive: params.includeInactive === undefined ? undefined : String(params.includeInactive),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_list_list>
        }

        public async listImages(params: { serviceId: number }): Promise<ResponseType<typeof api_services_list_images_listImages>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/images`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_list_images_listImages>
        }

        public async listVideos(params: { serviceId: number }): Promise<ResponseType<typeof api_services_upload_video_listVideos>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/videos`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_upload_video_listVideos>
        }

        public async reorderImages(params: RequestType<typeof api_services_reorder_images_reorderImages>): Promise<ResponseType<typeof api_services_reorder_images_reorderImages>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                imageOrder: params.imageOrder,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/images/reorder`, {method: "PUT", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_reorder_images_reorderImages>
        }

        public async update(params: RequestType<typeof api_services_update_update>): Promise<ResponseType<typeof api_services_update_update>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                basePricePence:       params.basePricePence,
                category:             params.category,
                description:          params.description,
                durationMinutes:      params.durationMinutes,
                isActive:             params.isActive,
                locationTypes:        params.locationTypes,
                materialsDescription: params.materialsDescription,
                materialsFee:         params.materialsFee,
                materialsPolicy:      params.materialsPolicy,
                mobilePricePence:     params.mobilePricePence,
                studioPricePence:     params.studioPricePence,
                styleIds:             params.styleIds,
                subcategory:          params.subcategory,
                title:                params.title,
                travelFee:            params.travelFee,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.id)}`, {method: "PUT", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_update_update>
        }

        public async uploadImage(params: RequestType<typeof api_services_upload_image_uploadImage>): Promise<ResponseType<typeof api_services_upload_image_uploadImage>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                displayOrder: params.displayOrder,
                image:        params.image,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/images`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_upload_image_uploadImage>
        }

        public async uploadVideo(params: RequestType<typeof api_services_upload_video_uploadVideo>): Promise<ResponseType<typeof api_services_upload_video_uploadVideo>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                mimeType:      params.mimeType,
                thumbnailData: params.thumbnailData,
                title:         params.title,
                videoData:     params.videoData,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/services/${encodeURIComponent(params.serviceId)}/videos`, {method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_services_upload_video_uploadVideo>
        }
    }
}


export namespace shared {
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { create as api_styles_create_create } from "~backend/styles/create";
import { remove as api_styles_delete_remove } from "~backend/styles/delete";
import { get as api_styles_get_get } from "~backend/styles/get";
import { list as api_styles_list_list } from "~backend/styles/list";
import { listAll as api_styles_list_all_listAll } from "~backend/styles/list_all";
import { listCategories as api_styles_list_categories_listCategories } from "~backend/styles/list_categories";
import { searchByStyle as api_styles_search_by_style_searchByStyle } from "~backend/styles/search_by_style";
import { update as api_styles_update_update } from "~backend/styles/update";
import { uploadImage as api_styles_upload_image_uploadImage } from "~backend/styles/upload_image";

export namespace styles {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.get = this.get.bind(this)
            this.list = this.list.bind(this)
            this.listAll = this.listAll.bind(this)
            this.listCategories = this.listCategories.bind(this)
            this.remove = this.remove.bind(this)
            this.searchByStyle = this.searchByStyle.bind(this)
            this.update = this.update.bind(this)
            this.uploadImage = this.uploadImage.bind(this)
        }

        public async create(params: RequestType<typeof api_styles_create_create>): Promise<ResponseType<typeof api_styles_create_create>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/styles`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_create_create>
        }

        public async get(params: { id: number }): Promise<ResponseType<typeof api_styles_get_get>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/styles/${encodeURIComponent(params.id)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_get_get>
        }

        public async list(params: RequestType<typeof api_styles_list_list>): Promise<ResponseType<typeof api_styles_list_list>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category: params.category,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/styles`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_list_list>
        }

        public async listAll(): Promise<ResponseType<typeof api_styles_list_all_listAll>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/styles`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_list_all_listAll>
        }

        public async listCategories(): Promise<ResponseType<typeof api_styles_list_categories_listCategories>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/styles/categories`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_list_categories_listCategories>
        }

        public async remove(params: { id: number }): Promise<ResponseType<typeof api_styles_delete_remove>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/styles/${encodeURIComponent(params.id)}`, {method: "DELETE", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_delete_remove>
        }

        public async searchByStyle(params: RequestType<typeof api_styles_search_by_style_searchByStyle>): Promise<ResponseType<typeof api_styles_search_by_style_searchByStyle>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:     params.category,
                limit:        params.limit === undefined ? undefined : String(params.limit),
                location:     params.location,
                locationType: params.locationType,
                maxPrice:     params.maxPrice === undefined ? undefined : String(params.maxPrice),
                minPrice:     params.minPrice === undefined ? undefined : String(params.minPrice),
                minRating:    params.minRating === undefined ? undefined : String(params.minRating),
                page:         params.page === undefined ? undefined : String(params.page),
                sortBy:       params.sortBy,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/styles/${encodeURIComponent(params.styleId)}/search`, {query, method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_search_by_style_searchByStyle>
        }

        public async update(params: RequestType<typeof api_styles_update_update>): Promise<ResponseType<typeof api_styles_update_update>> {
            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                description:       params.description,
                isActive:          params.isActive,
                name:              params.name,
                referenceImageUrl: params.referenceImageUrl,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/styles/${encodeURIComponent(params.id)}`, {method: "PUT", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_update_update>
        }

        public async uploadImage(params: RequestType<typeof api_styles_upload_image_uploadImage>): Promise<ResponseType<typeof api_styles_upload_image_uploadImage>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/admin/styles/upload-image`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_styles_upload_image_uploadImage>
        }
    }
}

/**
 * Import the endpoint handlers to derive the types for the client.
 */
import { adminApprove as api_verification_admin_approve_adminApprove } from "~backend/verification/admin_approve";
import { adminGet as api_verification_admin_get_adminGet } from "~backend/verification/admin_get";
import { adminList as api_verification_admin_list_adminList } from "~backend/verification/admin_list";
import { adminReject as api_verification_admin_reject_adminReject } from "~backend/verification/admin_reject";
import { completeKyc as api_verification_complete_kyc_completeKyc } from "~backend/verification/complete_kyc";
import { getDocument as api_verification_get_document_getDocument } from "~backend/verification/get_document";
import { getStatus as api_verification_get_status_getStatus } from "~backend/verification/get_status";
import { startKyc as api_verification_start_kyc_startKyc } from "~backend/verification/start_kyc";
import { submit as api_verification_submit_submit } from "~backend/verification/submit";
import { webhook as api_verification_webhook_webhook } from "~backend/verification/webhook";

export namespace verification {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.adminApprove = this.adminApprove.bind(this)
            this.adminGet = this.adminGet.bind(this)
            this.adminList = this.adminList.bind(this)
            this.adminReject = this.adminReject.bind(this)
            this.completeKyc = this.completeKyc.bind(this)
            this.getDocument = this.getDocument.bind(this)
            this.getStatus = this.getStatus.bind(this)
            this.startKyc = this.startKyc.bind(this)
            this.submit = this.submit.bind(this)
            this.webhook = this.webhook.bind(this)
        }

        public async adminApprove(params: RequestType<typeof api_verification_admin_approve_adminApprove>): Promise<ResponseType<typeof api_verification_admin_approve_adminApprove>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/admin/approve`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_admin_approve_adminApprove>
        }

        public async adminGet(params: { freelancerId: string }): Promise<ResponseType<typeof api_verification_admin_get_adminGet>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/admin/${encodeURIComponent(params.freelancerId)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_admin_get_adminGet>
        }

        public async adminList(): Promise<ResponseType<typeof api_verification_admin_list_adminList>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/admin/list`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_admin_list_adminList>
        }

        public async adminReject(params: RequestType<typeof api_verification_admin_reject_adminReject>): Promise<ResponseType<typeof api_verification_admin_reject_adminReject>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/admin/reject`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_admin_reject_adminReject>
        }

        public async completeKyc(params: RequestType<typeof api_verification_complete_kyc_completeKyc>): Promise<ResponseType<typeof api_verification_complete_kyc_completeKyc>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/complete-kyc`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_complete_kyc_completeKyc>
        }

        public async getDocument(params: { freelancerId: string }): Promise<ResponseType<typeof api_verification_get_document_getDocument>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/document/${encodeURIComponent(params.freelancerId)}`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_get_document_getDocument>
        }

        public async getStatus(): Promise<ResponseType<typeof api_verification_get_status_getStatus>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/status`, {method: "GET", body: undefined})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_get_status_getStatus>
        }

        public async startKyc(params: RequestType<typeof api_verification_start_kyc_startKyc>): Promise<ResponseType<typeof api_verification_start_kyc_startKyc>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/start-kyc`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_start_kyc_startKyc>
        }

        public async submit(params: RequestType<typeof api_verification_submit_submit>): Promise<ResponseType<typeof api_verification_submit_submit>> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/submit`, {method: "POST", body: JSON.stringify(params)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_submit_submit>
        }

        public async webhook(params: RequestType<typeof api_verification_webhook_webhook>): Promise<ResponseType<typeof api_verification_webhook_webhook>> {
            // Convert our params into the objects we need for the request
            const headers = makeRecord<string, string>({
                "x-signature": params.signature,
            })

            // Construct the body with only the fields which we want encoded within the body (excluding query string or header fields)
            const body: Record<string, any> = {
                event: params.event,
            }

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI(`/verification/webhook`, {headers, method: "POST", body: JSON.stringify(body)})
            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_verification_webhook_webhook>
        }
    }
}


type PickMethods<Type> = Omit<CallParameters, "method"> & { method?: Type };

// Helper type to omit all fields that are cookies.
type OmitCookie<T> = {
  [K in keyof T as T[K] extends CookieWithOptions<any> ? never : K]: T[K];
};

type RequestType<Type extends (...args: any[]) => any> =
  Parameters<Type> extends [infer H, ...any[]]
    ? OmitCookie<H>
    : void;

type ResponseType<Type extends (...args: any[]) => any> = OmitCookie<Awaited<ReturnType<Type>>>;

function dateReviver(key: string, value: any): any {
  if (
    typeof value === "string" &&
    value.length >= 10 &&
    value.charCodeAt(0) >= 48 && // '0'
    value.charCodeAt(0) <= 57 // '9'
  ) {
    const parsedDate = new Date(value);
    if (!isNaN(parsedDate.getTime())) {
      return parsedDate;
    }
  }
  return value;
}


function encodeQuery(parts: Record<string, string | string[]>): string {
    const pairs: string[] = []
    for (const key in parts) {
        const val = (Array.isArray(parts[key]) ?  parts[key] : [parts[key]]) as string[]
        for (const v of val) {
            pairs.push(`${key}=${encodeURIComponent(v)}`)
        }
    }
    return pairs.join("&")
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(record: Record<K, V | undefined>): Record<K, V> {
    for (const key in record) {
        if (record[key] === undefined) {
            delete record[key]
        }
    }
    return record as Record<K, V>
}

import {
  StreamInOutHandlerFn,
  StreamInHandlerFn,
  StreamOutHandlerFn,
} from "encore.dev/api";

type StreamRequest<Type> = Type extends
  | StreamInOutHandlerFn<any, infer Req, any>
  | StreamInHandlerFn<any, infer Req, any>
  | StreamOutHandlerFn<any, any>
  ? Req
  : never;

type StreamResponse<Type> = Type extends
  | StreamInOutHandlerFn<any, any, infer Resp>
  | StreamInHandlerFn<any, any, infer Resp>
  | StreamOutHandlerFn<any, infer Resp>
  ? Resp
  : never;


function encodeWebSocketHeaders(headers: Record<string, string>) {
    // url safe, no pad
    const base64encoded = btoa(JSON.stringify(headers))
      .replaceAll("=", "")
      .replaceAll("+", "-")
      .replaceAll("/", "_");
    return "encore.dev.headers." + base64encoded;
}

class WebSocketConnection {
    public ws: WebSocket;

    private hasUpdateHandlers: (() => void)[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        let protocols = ["encore-ws"];
        if (headers) {
            protocols.push(encodeWebSocketHeaders(headers))
        }

        this.ws = new WebSocket(url, protocols)

        this.on("error", () => {
            this.resolveHasUpdateHandlers();
        });

        this.on("close", () => {
            this.resolveHasUpdateHandlers();
        });
    }

    resolveHasUpdateHandlers() {
        const handlers = this.hasUpdateHandlers;
        this.hasUpdateHandlers = [];

        for (const handler of handlers) {
            handler()
        }
    }

    async hasUpdate() {
        // await until a new message have been received, or the socket is closed
        await new Promise((resolve) => {
            this.hasUpdateHandlers.push(() => resolve(null))
        });
    }

    on(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.addEventListener(type, handler);
    }

    off(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.removeEventListener(type, handler);
    }

    close() {
        this.ws.close();
    }
}

export class StreamInOut<Request, Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data, dateReviver));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamIn<Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data, dateReviver));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamOut<Request, Response> {
    public socket: WebSocketConnection;
    private responseValue: Promise<Response>;

    constructor(url: string, headers?: Record<string, string>) {
        let responseResolver: (_: any) => void;
        this.responseValue = new Promise((resolve) => responseResolver = resolve);

        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            responseResolver(JSON.parse(event.data, dateReviver))
        });
    }

    async response(): Promise<Response> {
        return this.responseValue;
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, "headers"> & {
    /** Headers to be sent with the request */
    headers?: Record<string, string>

    /** Query parameters to be sent with the request */
    query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
  | RequestType<typeof auth_auth>
  | Promise<RequestType<typeof auth_auth> | undefined>
  | undefined;

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch;

const boundFetch = fetch.bind(this);

class BaseClient {
    readonly baseURL: string
    readonly fetcher: Fetcher
    readonly headers: Record<string, string>
    readonly requestInit: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }
    readonly authGenerator?: AuthDataGenerator

    constructor(baseURL: string, options: ClientOptions) {
        this.baseURL = baseURL
        this.headers = {}

        // Add User-Agent header if the script is running in the server
        // because browsers do not allow setting User-Agent headers to requests
        if (!BROWSER) {
            this.headers["User-Agent"] = "-Generated-TS-Client (Encore/1.53.2)";
        }

        this.requestInit = options.requestInit ?? {};

        // Setup what fetch function we'll be using in the base client
        if (options.fetcher !== undefined) {
            this.fetcher = options.fetcher
        } else {
            this.fetcher = boundFetch
        }

        // Setup an authentication data generator using the auth data token option
        if (options.auth !== undefined) {
            const auth = options.auth
            if (typeof auth === "function") {
                this.authGenerator = auth
            } else {
                this.authGenerator = () => auth
            }
        }
    }

    async getAuthData(): Promise<CallParameters | undefined> {
        let authData: RequestType<typeof auth_auth> | undefined;

        // If authorization data generator is present, call it and add the returned data to the request
        if (this.authGenerator) {
            const mayBePromise = this.authGenerator();
            if (mayBePromise instanceof Promise) {
                authData = await mayBePromise;
            } else {
                authData = mayBePromise;
            }
        }

        if (authData) {
            const data: CallParameters = {};

            data.headers = makeRecord<string, string>({
                authorization: authData.authorization,
            });

            return data;
        }

        return undefined;
    }

    // createStreamInOut sets up a stream to a streaming API endpoint.
    async createStreamInOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamInOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamInOut(this.baseURL + path + queryString, headers);
    }

    // createStreamIn sets up a stream to a streaming API endpoint.
    async createStreamIn<Response>(path: string, params?: CallParameters): Promise<StreamIn<Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamIn(this.baseURL + path + queryString, headers);
    }

    // createStreamOut sets up a stream to a streaming API endpoint.
    async createStreamOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamOut(this.baseURL + path + queryString, headers);
    }

    // callTypedAPI makes an API call, defaulting content type to "application/json"
    public async callTypedAPI(path: string, params?: CallParameters): Promise<Response> {
        return this.callAPI(path, {
            ...params,
            headers: { "Content-Type": "application/json", ...params?.headers }
        });
    }

    // callAPI is used by each generated API method to actually make the request
    public async callAPI(path: string, params?: CallParameters): Promise<Response> {
        let { query, headers, ...rest } = params ?? {}
        const init = {
            ...this.requestInit,
            ...rest,
        }

        // Merge our headers with any predefined headers
        init.headers = {...this.headers, ...init.headers, ...headers}

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                init.headers = {...init.headers, ...authData.headers};
            }
        }

        // Make the actual request
        const queryString = query ? '?' + encodeQuery(query) : ''
        const response = await this.fetcher(this.baseURL+path+queryString, init)

        // handle any error responses
        if (!response.ok) {
            // try and get the error message from the response body
            let body: APIErrorResponse = { code: ErrCode.Unknown, message: `request failed: status ${response.status}` }

            // if we can get the structured error we should, otherwise give a best effort
            try {
                const text = await response.text()

                try {
                    const jsonBody = JSON.parse(text)
                    if (isAPIErrorResponse(jsonBody)) {
                        body = jsonBody
                    } else {
                        body.message += ": " + JSON.stringify(jsonBody)
                    }
                } catch {
                    body.message += ": " + text
                }
            } catch (e) {
                // otherwise we just append the text to the error message
                body.message += ": " + String(e)
            }

            throw new APIError(response.status, body)
        }

        return response
    }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
    code: ErrCode
    message: string
    details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
    return (
        err !== undefined && err !== null &&
        isErrCode(err.code) &&
        typeof(err.message) === "string" &&
        (err.details === undefined || err.details === null || typeof(err.details) === "object")
    )
}

function isErrCode(code: any): code is ErrCode {
    return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
    /**
     * The HTTP status code associated with the error.
     */
    public readonly status: number

    /**
     * The Encore error code
     */
    public readonly code: ErrCode

    /**
     * The error details
     */
    public readonly details?: any

    constructor(status: number, response: APIErrorResponse) {
        // extending errors causes issues after you construct them, unless you apply the following fixes
        super(response.message);

        // set error name as constructor name, make it not enumerable to keep native Error behavior
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
        Object.defineProperty(this, 'name', {
            value:        'APIError',
            enumerable:   false,
            configurable: true,
        })

        // fix the prototype chain
        if ((Object as any).setPrototypeOf == undefined) {
            (this as any).__proto__ = APIError.prototype
        } else {
            Object.setPrototypeOf(this, APIError.prototype);
        }

        // capture a stack trace
        if ((Error as any).captureStackTrace !== undefined) {
            (Error as any).captureStackTrace(this, this.constructor);
        }

        this.status = status
        this.code = response.code
        this.details = response.details
    }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
    return err instanceof APIError;
}

export enum ErrCode {
    /**
     * OK indicates the operation was successful.
     */
    OK = "ok",

    /**
     * Canceled indicates the operation was canceled (typically by the caller).
     *
     * Encore will generate this error code when cancellation is requested.
     */
    Canceled = "canceled",

    /**
     * Unknown error. An example of where this error may be returned is
     * if a Status value received from another address space belongs to
     * an error-space that is not known in this address space. Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     *
     * Encore will generate this error code in the above two mentioned cases.
     */
    Unknown = "unknown",

    /**
     * InvalidArgument indicates client specified an invalid argument.
     * Note that this differs from FailedPrecondition. It indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     *
     * This error code will not be generated by the gRPC framework.
     */
    InvalidArgument = "invalid_argument",

    /**
     * DeadlineExceeded means operation expired before completion.
     * For operations that change the state of the system, this error may be
     * returned even if the operation has completed successfully. For
     * example, a successful response from a server could have been delayed
     * long enough for the deadline to expire.
     *
     * The gRPC framework will generate this error code when the deadline is
     * exceeded.
     */
    DeadlineExceeded = "deadline_exceeded",

    /**
     * NotFound means some requested entity (e.g., file or directory) was
     * not found.
     *
     * This error code will not be generated by the gRPC framework.
     */
    NotFound = "not_found",

    /**
     * AlreadyExists means an attempt to create an entity failed because one
     * already exists.
     *
     * This error code will not be generated by the gRPC framework.
     */
    AlreadyExists = "already_exists",

    /**
     * PermissionDenied indicates the caller does not have permission to
     * execute the specified operation. It must not be used for rejections
     * caused by exhausting some resource (use ResourceExhausted
     * instead for those errors). It must not be
     * used if the caller cannot be identified (use Unauthenticated
     * instead for those errors).
     *
     * This error code will not be generated by the gRPC core framework,
     * but expect authentication middleware to use it.
     */
    PermissionDenied = "permission_denied",

    /**
     * ResourceExhausted indicates some resource has been exhausted, perhaps
     * a per-user quota, or perhaps the entire file system is out of space.
     *
     * This error code will be generated by the gRPC framework in
     * out-of-memory and server overload situations, or when a message is
     * larger than the configured maximum size.
     */
    ResourceExhausted = "resource_exhausted",

    /**
     * FailedPrecondition indicates operation was rejected because the
     * system is not in a state required for the operation's execution.
     * For example, directory to be deleted may be non-empty, an rmdir
     * operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FailedPrecondition, Aborted, and Unavailable:
     *  (a) Use Unavailable if the client can retry just the failing call.
     *  (b) Use Aborted if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FailedPrecondition if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FailedPrecondition
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FailedPrecondition if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     *
     * This error code will not be generated by the gRPC framework.
     */
    FailedPrecondition = "failed_precondition",

    /**
     * Aborted indicates the operation was aborted, typically due to a
     * concurrency issue like sequencer check failures, transaction aborts,
     * etc.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     */
    Aborted = "aborted",

    /**
     * OutOfRange means operation was attempted past the valid range.
     * E.g., seeking or reading past end of file.
     *
     * Unlike InvalidArgument, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate InvalidArgument if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OutOfRange if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FailedPrecondition and
     * OutOfRange. We recommend using OutOfRange (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OutOfRange error to detect when
     * they are done.
     *
     * This error code will not be generated by the gRPC framework.
     */
    OutOfRange = "out_of_range",

    /**
     * Unimplemented indicates operation is not implemented or not
     * supported/enabled in this service.
     *
     * This error code will be generated by the gRPC framework. Most
     * commonly, you will see this error code when a method implementation
     * is missing on the server. It can also be generated for unknown
     * compression algorithms or a disagreement as to whether an RPC should
     * be streaming.
     */
    Unimplemented = "unimplemented",

    /**
     * Internal errors. Means some invariants expected by underlying
     * system has been broken. If you see one of these errors,
     * something is very broken.
     *
     * This error code will be generated by the gRPC framework in several
     * internal error conditions.
     */
    Internal = "internal",

    /**
     * Unavailable indicates the service is currently unavailable.
     * This is a most likely a transient condition and may be corrected
     * by retrying with a backoff. Note that it is not always safe to retry
     * non-idempotent operations.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     *
     * This error code will be generated by the gRPC framework during
     * abrupt shutdown of a server process or network connection.
     */
    Unavailable = "unavailable",

    /**
     * DataLoss indicates unrecoverable data loss or corruption.
     *
     * This error code will not be generated by the gRPC framework.
     */
    DataLoss = "data_loss",

    /**
     * Unauthenticated indicates the request does not have valid
     * authentication credentials for the operation.
     *
     * The gRPC framework will generate this error code when the
     * authentication metadata is invalid or a Credentials callback fails,
     * but also expect authentication middleware to generate it.
     */
    Unauthenticated = "unauthenticated",
}

export default new Client(import.meta.env.VITE_CLIENT_TARGET, { requestInit: { credentials: "include" } });
